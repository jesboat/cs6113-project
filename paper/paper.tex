\documentclass[a4paper,twocolumn]{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
%\usepackage{float}
%\floatstyle{boxed}
%\restylefloat{figure}

\newcommand{\langName}[0]{TinyML\textsuperscript{2}}
\newcommand{\origLang}[0]{CoreML\textsuperscript{2}}
\newcommand{\typeRule}[3]{#1 \vdash #2 \colon #3}
\newcommand{\guards}[0]{\lhd}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}
\newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem*{case}{Case}

\title{Towards a Mechanized Proof of Noninterference}
\author{Tom Magrino \and Matthew Milano}
\begin{document}

\maketitle

\abstract

In this paper we discuss our experience trying to mechanize a proof of
noninterference for a simple language with security labels, \langName.  This
marks the first step towards writing a verified compiler for a language with
information flow types.  Although we did not complete the full noninterference
proof because we ran out of time, we were able to find small inaccuracies and
subtleties in the proofs from the paper we based our proof on.  We discuss what
would be involved in completing the proof and how this relates to other work.

\section{Introduction}

Verified systems have been growing in popularity recently with the rise of proof
assistants like Coq and NuPRL~\cite{coqart,nuprl}.  These systems allow a
programmer to write programs and have proofs, which are checked and compiled by
the system, which can assert various properties about the programs.  As we will
discuss in Section~\ref{sec:related}, these systems have been used to formalize,
prove correct, and implement systems that have verified properties.  This allows
for programmers to be more confident in their languages and programs, ensuring
that the properties they want are actually properties of their work.

Interestingly, as far as we know there has not been work to formalize and verify
a language, like Jif~\cite{myers1999jflow} or FlowCaml~\cite{simonet2003flow},
that has a type system for enforcing information flow security policies.  For
languages like these and other systems related to security, it is desirable for
the program to be accompanied with a proof of the security properties it
enforces.  Our goal is to make progress towards verifying the correctness of a
compiler for a language with information flow types that programmers will want
to use.

A verified compiler for a language like Jif would require a proof of
noninterference, which asserts that any program in the language will never
produce different outputs for low security items if only the high security input
values are varied.  Thus, in this paper we discuss our experience working
towards proving this theorem for a simple information flow type system as a
first step towards creating a verified information flow compiler.

Our language, \langName,  and proof are a simplified version of what is
presented in Simonet and Pottier's work on information flow for an ML-like
language, \origLang~\cite{InfoFlowML}.  This proof proceeds by designing a
language that includes values which represent two different alternatives,
representing the different values of high security items in two different
executions of the program.  The proof then becomes a matter of proving that if
the program is typed with a low security label, this does not produce a value
that could be different between two different executions of the program.

In this paper we will present our simplified language, \langName,
along with the semantics and type system (Section~\ref{sec:lang}).  We will then
present a natural language, human readable, proof of noninterference for the
language and discuss our experiences with mechanizing this proof in the Coq
proof assistant (Sections~\ref{sec:proof} and \ref{sec:mechanizing}).  Finally,
we will discuss related work, next steps, and conclude
(Sections~\ref{sec:related}, \ref{sec:future}, and \ref{sec:conclusion}).

\section{\langName}
\label{sec:lang}

Our toy language for proving noninterference, \langName, is a simplified version
of \origLang from Simonet and Pottier's paper~\cite{InfoFlowML}.  Since we had a
limited amount of time to work on this project, we limited ourselves to a subset
of the language that drops the following features:

\begin{itemize}
  \item References and associated memory operations.
  \item Paired values.
  \item Exceptions.
  \item Sequencing operations.
\end{itemize}

While the language becomes much much less interesting for actual programming, we
feel that these features do not fundamentally change the problem of proving
noninterference.  In order to mechanize a proof of noninterference for a
language closer to \origLang, it would require simply adding mechanized proofs
for the additional cases where appropriate.

Furthermore, primarily due to a matter of taste, we decided to replace the
\textsf{case} construct from \origLang for an \textsf{if} construct, which
evaluates the first expression if the test evaluates to 1 and evaluates to the
second expression otherwise.

\langName, like \origLang, includes angle bracketed expressions, which represent
values or expressions which could differ between two runs of the program.  As we
will see when discussing the type system, this corresponds to values and
expressions that have high security labels on their types.

Through these changes, our language has the syntax shown in
Figure~\ref{fig:syntax}.  As shown, final states, answers, in the language are
now simple values because there are no exceptions.

\begin{figure}[t]
  \begin{align}
    v & ::= x \: | \: k \: | \: \textsf{fix} f . \lambda x . e \tag*{ } \\
    v' & ::= v \: | \: <v | v> \tag{values}\\
    a & ::= v \tag*{ } \\
    a' & ::= a \: | \: <a | a> \tag{answers} \\
    e & ::= a \: | \: v v \: | \: \textsf{if } v \: e \: e \: | \: \textsf{let
    } x := v \textsf{ in } e \tag*{ } \\
    e' & ::= e \: | \: <e | e> \tag{expressions}
  \end{align}
  \caption{Syntax of \langName.  The prime variants are the full class of
  expressions, values, and answers.  This construction avoids allowing nested
  branching values.}
  \label{fig:syntax}
\end{figure}

In the following two subsections, we introduce the operational semantics and
type system for the language.

\subsection{Operational Semantics}

\langName has an operational semantics that should be familiar to the reader who
has seen a single step semantics for a basic lambda calculus.  The interesting
additions are the same as those in \origLang, where there are additional rules
for handling the bracketed values.  The reduction rules for the semantics are
given in Figure~\ref{fig:operational_semantics}.

\begin{figure*}[t]
  Basic reductions
  \begin{align}
    (\textsf{fix} f . \lambda x . e) v
    \: \to \: &
    e[x \Leftarrow v][f \Leftarrow \textsf{fix} f . \lambda x . e]
    \tag{$\beta$}
    \label{eq:beta}
    \\
    \textsf{if } 1 \: e_1 \textsf { } e_2
    \: \to \: &
    e_1
    \tag{if-true}
    \label{eq:if-true}
    \\
    \textsf{if } (k \neq 1) \textsf { } e_1 \textsf { } e_2
    \: \to \: &
    e_2
    \tag{if-false}
    \label{eq:if-false}
    \\
    \textsf{let }  x := v \textsf{ in } e
    \: \to \: &
    e[x \Leftarrow v]
    \tag{let}
    \label{eq:let}
  \end{align}

  Lifting
  \begin{align}
    < v_1 | v_2 > v
    \: \to \: &
    < v_1 \lift{v}_1 | v_2 \lift{v}_2 >
    \tag{lift-app}
    \label{eq:lift-app}
    \\
    \textsf{if } < v_1 | v_2 > \: e_1 \: e_2
    \: \to \: &
    < \textsf{if } v_1 \: \lift{e_1}_1 \: \lift{e_2}_1 \: |
    \textsf{ if } v_2 \: \lift{e_1}_2 \: \lift{e_2}_2 >
    \tag{lift-if}
    \label{eq:lift-if}
    \\
    &
    \infer*
    {
    e_1 \to e_1' \\
    }
    {
    <e_1 | e_2> \: \to \: <e_1' | e_2>
    }
    \tag{bracket-left}
    \label{eq:bracket-left}
    \\
    &
    \infer*
    {
    e_2 \to e_2' \\
    }
    {
    <e_1 | e_2> \: \to \: <e_1 | e_2'>
    }
    \tag{bracket-right}
    \label{eq:bracket-right}
  \end{align}
  \caption{Operational semantics for \langName.}
  \label{fig:operational_semantics}
\end{figure*}

At a high level, these bracketed expressions are evaluated by evaluating one of
the branches, as shown in rules \ref{eq:bracket-left} and
\ref{eq:bracket-right}, or by expanding the brackets around the parent
expression, passing the appropriate branch of the bracketed subvalue to each
branch of the resulting expression, as shown in rules \ref{eq:lift-app} and
\ref{eq:lift-if}.  In these rules, we use the notation $\lift{x}_i$ to denote
the left ($i = 1$) or right ($i = 2$) branch of a bracketed expression or value
$x$.

We prove soundness and completeness lemmas for these rules in
Section~\ref{sec:proof}.

\subsection{Type System}

\langName has a very simple type system, including only integers and lambda
abstractions, which include fixpoints by default, along with appropriate
security labels for both, as shown in Figure~\ref{fig:types}.  In \langName,
security labels specify confidentiality policies, specifying what other data the
labelled data can affect.\footnote{It is not difficult to imagine how to extend
our system to include integrity labels.  However, for the sake of simplicity, we
decided to concern ourselves with only confidentiality at first}  Data can only
be affected by items at the same label or lower (so high data can not affect low
labelled data).

\begin{figure}[t]
  \begin{align*}
    t ::= int^l \: | \: (t \to t)^l
  \end{align*}
  \caption{Types for \langName}
  \label{fig:types}
\end{figure}

A reader familiar with the type system for \origLang will notice that our type
system does not include types above the arrow in the function type, for giving
security bounds on side effects of the function, and the type does not include
effect labels for exceptions.  These are dropped as a result of the
simplifications we made in defining \langName, since there are no side effects
or exceptions in the language.

The language's type system includes subtyping, which allows data that have a
lower label to flow into higher labelled data.  We use the notatoin $x \leq y$
to denote that $x$ is a subtype of $y$, whether both $x$ and $y$ are labels or
types (as long as both are the same kind of value).  The rules for subtyping are
given in Figure~\ref{fig:subtype_rules}.  Rule \textsc{S-Int} states that
integers are subtypes of integers with equivalent or higher labels in the label
lattice.  Similarly, rule \textsc{S-Abs} gives the standard subtyping
relationship for functions along with the same label relation.

\begin{figure}[t]
  \begin{mathpar}
    \infer[S-Int]
    {
    l \leq l'
    }
    {
    \textsf{int}^l \leq \textsf{int}^{l'}
    }

    \infer[S-Abs]
    {
    t_{in}' \leq t_{in} \\
    t_{out} \leq t_{out}' \\
    l \leq l'
    }
    {
    (t_{in} \to t_{out})^l \leq (t_{in}' \to t_{out}')^{l'}
    }
  \end{mathpar}
  \caption{Rules for subtyping in \langName.}
  \label{fig:subtype_rules}
\end{figure}

For the sake of being able to discuss how strong labels are in relation to a
type, we follow the example of Simonet and Pottier~\cite{InfoFlowML} and define
a ``guards'' relation between labels and types, denoted $l \guards t$, which
states that the label $l$ is at least as restrictive as the label on the type
$t$.  In other words, this requires that the type has at least $l$ for it's
security label.  The two rules regarding this relationships for both types in
our language are given in Figure~\ref{fig:guard_rules}.

\begin{figure}[t]
  \begin{mathpar}
    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards \textsf{int}^{l'}
    }

    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards (* \to *)^{l'}
    }
  \end{mathpar}
  \caption{Rules for labels guarding types in \langName.}
  \label{fig:guard_rules}
\end{figure}

Figure~\ref{fig:value_types} includes typing judgements for values in the
language, which are mostly straight forward with the exception of
\textsc{V-Bracket}, which we discuss below along with the type rules for
expressions.

\begin{figure*}[t]
  \begin{mathpar}
    \infer[V-Int]
    { }
    {\typeRule{\Gamma}{k}{\textsf{int}^{*}}}

    \infer[V-Var]
    {t \in \Gamma(x)}
    {\typeRule{\Gamma}{x}{t}}

    \infer[V-Abs]
    {\typeRule{pc, \Gamma[x \mapsto t'][f \mapsto (t \to t')^l]}{e}{t}}
    {\typeRule{\Gamma}{\textsf{fix} f . \lambda x . e}{(t \to t')^l}}

    \infer[V-Bracket]
    {
    \typeRule{\Gamma}{v_1}{t} \\
    \typeRule{\Gamma}{v_2}{t} \\
    l \in H \\
    l \guards t
    }
    {\typeRule{\Gamma}{<v_1 | v_2>}{t}}

    \infer[V-Sub]
    {
    \typeRule{\Gamma}{v}{t'} \\
    t' \leq t
    }
    {\typeRule{\Gamma}{v}{t}}
  \end{mathpar}
  \caption{Typing judgements for values in \langName.}
  \label{fig:value_types}
\end{figure*}

The typing rules for expressions in the language are given in
Figure~\ref{fig:expr_types}.  Unlike a typical typing judgment, we include an
additional piece of context information, the $pc$, which is a label that
describes what level of label can influence the control structure decisions to
reach the current expression in the program.  This is a standard extension for
languages with information flow types, like Jif.

The interesting rules in the type system are \textsc{V-Bracket},
\textsc{E-Bracket}, and \textsc{E-If}.  \textsc{E-If} is a standard rule for
information flow type systems, stating that the type determinations for each
branch must have a $pc$ equivalent to the security of the original $pc$ along
with the security of the label on the value in the test, $l$.

\textsc{V-Bracket} and \textsc{E-Bracket} both require that there exists a label
from the set $H$ which representes an upward closed sublattice of the labels in
the system representing what is considered to be ``high'' security for the
purposes of the proof of noninterference, discussed later.  These rules require
that the types of each branch of a bracketed value or expression can be typed
with a high security label.  Furthermore, \textsc{E-Bracket} requires that the
$pc$ of the subexpressions must be at least as high as this same label,
requiring that we treat everything in the subexpression as affected by high
security information.

\begin{figure*}[t]
  \begin{mathpar}
    \infer[E-Value]
    {
    \typeRule{\Gamma}{v}{t}
    }
    {
    \typeRule{*, \Gamma}{v}{t}
    }

    \infer[E-App]
    {
    \typeRule{\Gamma}{v_1}{(t' \to t)^l} \\
    \typeRule{\Gamma}{v_2}{t'} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{v_1 v_2}{t}
    }

    \infer[E-If]
    {
    \typeRule{pc, \Gamma}{e_{test}}{\textsf{int}^l} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{true}}{t} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{false}}{t} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{\textsf{if } e_{test} \: e_{true} \: e_{false}}{t}
    }

    \infer[E-Let]
    {
    \typeRule{\Gamma}{v}{s} \\
    \typeRule{pc, \Gamma[x \mapsto s]}{e}{t} \\
    }
    {
    \typeRule{pc, \Gamma}{\textsf{let } x := s \textsf{ in } e}{t}
    }

    \infer[E-Sub]
    {
    \typeRule{pc, \Gamma}{e}{t'} \\
    t' \leq t
    }
    {
    \typeRule{pc, \Gamma}{e}{t}
    }

    \infer[E-Bracket]
    {
    \typeRule{pc \sqcup pc', \Gamma}{e_1}{t} \\
    \typeRule{pc \sqcup pc', \Gamma}{e_2}{t} \\
    pc' \in H \\
    pc' \guards t
    }
    {
    \typeRule{pc, \Gamma}{<e_1 | e_2>}{t}
    }
  \end{mathpar}
  \caption{Typing judgements for expressions in \langName.}
  \label{fig:expr_types}
\end{figure*}

\section{Proof of Noninterference}
\label{sec:proof}

Before discussing the task of mechanizing a noninterference proof for \langName,
it is useful to first view what the natural language proof would look like
first.  We first start by proving some supporting lemmas about the language's
semantics and type system, and finish with a proof of noninterference for the
language.  Since \langName is a stripped down version of \origLang, the proofs
will look like a simplified version of the proofs found in Pottier and Simonet's
paper~\cite{InfoFlowML}.

We start with soundness and completeness lemmas for the operational semantics,
showing that this language can accurately describe the process of evaluating two
different runs of a language where bracketed expressions are high security
values.  Specifically, the image of a valid reduction of an expression is also a
valid reduction and if both runs of a program evaluate to an answer, then so can
the bracketed expression in \langName.

\begin{lemma}[Soundness]
  \label{lem:soundness}
  Let $i \in \{1, 2\}$. If $e \to e'$, then $\lift{e}_i \to^*
  \lift{e'}_i$.\footnote{Notice that this is not the same statement as the
  Soundness lemma in Simonet and Pottier's paper~\cite{InfoFlowML}, which does
  not give a variable number of steps for the conclusion.  We will discuss this
  change in Section~\ref{sec:mechanizing}.}
\end{lemma}
\begin{proof}
  This can be seen by examining each of the operational semantics rules in
  Figure~\ref{fig:operational_semantics}.
\end{proof}

\begin{lemma}
  \label{lem:stuck_bracket}
  If $e$ is stuck, then $\lift{e}_i$is stuck for some $i \in \{1, 2\}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $e$.

  \begin{case}[$e = v$]
    In this case, $e$ is not stuck.
  \end{case}

  \begin{case}[$e = v_1 v_2$]
    If $e$ is stuck and is an application, this means that neither
    \ref{eq:beta} nor \ref{eq:lift-app} applies.  This means that $v_1$ can
    neither be a fixpoint function or some bracketed value.  As a result,
    $\lift{v_1}_i$ can not be a fixpoint function, and so it is stuck.
  \end{case}

  \begin{case}[$e = \textsf{ if } v \: e_1 \: e_2$ or $e =
    \textsf{ let } x := v \textsf{ in } e$]
    These are similar to the previous case.  The value $v$ can not be an integer
    and so the lifted version of $v$ can not be an integer, meaning the lifted
    expression is also stuck.
  \end{case}

  \begin{case}[$e = < e_1 | e_2 >$]
    Since $e$ is stuck, then by \ref{eq:bracket-left} and \ref{eq:bracket-right}
    we know that both $e_1$ and $e_2$ must be stuck.  Since $e$ is not an
    answer, we know either $e_1$ or $e_2$ must not be an answer and, as a
    result, stuck.
  \end{case}
\end{proof}

\begin{lemma}[Completeness]
  \label{lem:completeness}
  Assume $\lift{e}_i \to^* a_i$ for all $i \in \{1, 2\}$.  Then, there exists an
  answer $a$ such that $e \to^* a$.
\end{lemma}
\begin{proof}
  First, we establish that if $\lift{e}_i$ reduces to an answer in a finite
  number of steps, then $e$ does not have an infinite reduction sequence.  The
  only way this could occur is if $e$ was infinitely reduced over lift rules,
  because otherwise, since the only reductions on $e$ that correspond to 0
  reductions on either projection are lift reduction rules.  But as we can see
  from inspecting the lift reduction rules, we cannot continuously apply these
  rules exclusively.  Thus, we can conclude that $e$ does not have an infinite
  series of reduction steps that can be applied to it.

  As a result, we know that $e$ reduces to an answer, because otherwise it would
  be stuck and this would mean that one of the projections is also stuck by
  Lemma~\ref{lem:stuck_bracket}, a contradicton.  Thus, we know that if both
  projections step to an answer, so must the original expression.
\end{proof}

Next, we prove lemmas related to the type system.  We start with a lemma showing
that $\guards$ interacts well with subtyping and a weakening lemma, showing that
anything typed at a given $pc$ can be typed at a lower $pc'$ as well.

\begin{lemma}
  \label{lem:guard_subtype}
  If $l' \leq l$ and $l \guards t$ and $t \leq t'$, then $l' \guards t'$.
\end{lemma}
\begin{proof}
  $l \guards t$ is equivalent to $l \leq level(t)$ where $level$ is a function
  that takes a type and returns the label on that type.  It's simple to see that
  $level$ is covariant in its argument.  The result follows.
\end{proof}

\begin{lemma}[Weakening]
  \label{lem:weakening}
  $pc' \leq pc$ and $\typeRule{pc, \Gamma}{e}{t}$ imply $\typeRule{pc',
  \Gamma}{e}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\typeRule{pc, \Gamma}{e}{t}$.  By the
  monotonicity of $\sqcup$, rule \textsc{V-Sub}, Lemma~\ref{lem:guard_subtype},
  and the inductive hypothesis, it can be checked that the premise remains valid
  when $pc$ is lowered.
\end{proof}

We now prove a projection lemma, showing that if a top level expression or value
is well typed, so must either projection of that expression or value to one
program run or another.

\begin{lemma}[Projection]
  \label{lem:projection}
  Let $i \in \{1, 2\}$.  If $\typeRule{\Gamma}{v}{t}$ then
  $\typeRule{\Gamma}{\lift{v}_i}{t}$.  If $\typeRule{pc, \Gamma}{e}{t}$ then
  $\typeRule{pc, \Gamma}{\lift{e}_i}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation for $v$ and $e$.  The only interesting case is
  that of \textsc{E-Bracket}, since other cases end up either being trivial or
  using the inductive hypothesis for a case of \textsc{E-Bracket}.  The
  expression is $<e_1 | e_2>$.  Since $pc \sqcup pc' \leq pc$, by
  Lemma~\ref{lem:weakening} and the inductive hypothesis, we can prove the
  typing judgements for both branches.
\end{proof}

Below is a lemma showing that if a bracketed expression is well typed, then
there must exist a high security label to use for the types and $pc$ of both
branches.

\begin{lemma}[Guard]
  \label{lem:guard}
  If $\typeRule{\Gamma}{< v_1 | v_2 >}{t}$ then there exists $pc' \in H$ s.t.
  $pc' \guards t$.
\end{lemma}
\begin{proof}
  Through Lemma~\ref{lem:guard_subtype}, we can see that we can always construct
  a typing derivation that does not end with \textsc{V-Sub}.  As a result, the
  derivation can always end with \textsc{V-Bracket}, which has the premises $pc'
  \in H$ and $pc' \guards t$.
\end{proof}

Here we prove a standard substitution lemma for the type system.

\begin{lemma}[Substitution]
  \label{lem:substitution}
  Assume $\typeRule{ }{v}{s}$.  Then, $\typeRule{\Gamma[x \mapsto s]}{v'}{t}$
  implies $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.  Also $\typeRule{pc,
  \Gamma[x \mapsto s]}{e}{t}$ implies $\typeRule{pc, \Gamma}{e[x \Leftarrow
  v]}{t}$.
\end{lemma}
\begin{proof}
  We can prove both statements by induction on the typing derivation for $v'$
  and $e$.  In this proof, we focus only on a subset of the cases.

  \begin{case}[\textsc{V-Int}]
    This is trivial, since $x$ does not get substituted in $v'$ and so the
    statement becomes a tautology.
  \end{case}

  \begin{case}[\textsc{V-Var}]
    If $v'$ is $x$, then we are in the case where $s \in t$.  Thus, we can
    conclude that given $\typeRule{ }{v}{s}$, $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ by \textsc{V-Var}.  Since $v'[x \Leftarrow v] = v$, we can
    conclude $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.

    Otherwise, we are in the case where $v'$ is some variable $y \neq x$.
    Then, given that $v'[x \Leftarrow v] = v' = y$ and since $\Gamma(y) =
    \Gamma[x \mapsto s]$, we can see that $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ implies that $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Abs}]
    The premise in this case becomes $\typeRule{pc, \Gamma[x \mapsto s][y
    \mapsto t'][f \mapsto (t' \to t'')^l]}{e'}{t''}$.

    Let us assume that $x$, $f$, and $y$ are distinct, since otherwise this
    would reduce to a similar situation to that of \textsc{V-Var} when the
    variable substitution leaves $v'$ unchanged, which is trivial.  Since they
    are distinct, $\Gamma[x \mapsto s][y \mapsto t'][f \mapsto (t' \to t'')^l]$
    is equivalent to $\Gamma[y \mapsto t'][f \mapsto (t' \to t'')^l][x \mapsto
    s]$ and so we can apply the inductive hypothesis and \textsc{V-Abs} to show
    $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Bracket}]
    In this case the premises are of the form $\typeRule{\Gamma[x \mapsto
    s]}{v'_i}{t}$.  By Lemma~\ref{lem:projection}, we know that
    $\typeRule{\Gamma}{v}{s}$ implies $\typeRule{\Gamma}{\lift{v}_i}{s}$.  By
    the inductive hypothesis, we can then say that $\typeRule{\Gamma}{v'_i[x
    \Leftarrow v]}{t}$ holds.  Thus, we can apply \textsc{V-Bracket} to obtain
    $\typeRule{\Gamma}{<v'_1[x \Leftarrow v] | v'_2[x \Leftarrow v]>}{t}$,
    proving the statement.
  \end{case}

  \begin{case}[\textsc{V-Sub}, \textsc{E-Value}, \textsc{E-App}, \textsc{E-If},
    \textsc{E-Let}, \textsc{E-Sub}]
    Applying the inductive hypothesis on the premises and applying the
    associated rule proves these cases.
  \end{case}

  \begin{case}[\textsc{E-Bracket}]
    This case is similar to the case of \textsc{V-Bracket}.
    Lemma~\ref{lem:guard} allows us to apply \textsc{E-Bracket} where necessary.
  \end{case}
\end{proof}

The following lemma asserts that if a value is well typed, the expression
containing just that value is also well typed.

\begin{lemma}[Value]
  \label{lem:value}
  $\typeRule{pc}{v}{t}$ implies $\typeRule{ }{v}{t}$
\end{lemma}
\begin{proof}
  By induction on the proof of $\typeRule{pc}{v}{t}$.  The cases are either that
  we have \textsc{E-Value}, where we're done, \textsc{E-Sub}, in which case we
  apply the inductive hypothesis and the rule \textsc{V-Sub}, or we have
  \textsc{E-Bracket}, which is proved by the inductive hypothesis and
  \textsc{V-Bracket}.
\end{proof}

We also prove a subject reduction lemma, allowing us to assert that if an
expression is well typed and there is a reduction that can apply to it, then the
reduced form is also well typed, with the same type.

\begin{lemma}[Subject Reduction]
  \label{lem:subj_red}
  Let $e \to e'$.  Assume $\typeRule{pc}{e}{t}$ and $pc \in H$ for all $i \in
  \{1, 2\}$.  Then $\typeRule{pc}{e'}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $e \to e'$.
  \begin{case}[$\beta$]
    \todo{}
  \end{case}

  \begin{case}[if]
    \todo{}
  \end{case}

  \begin{case}[let]
    \todo{}
  \end{case}

  \begin{case}[lift-app]
    \todo{}
  \end{case}

  \begin{case}[lift-if]
    \todo{}
  \end{case}

  \begin{case}[bracket]
    \todo{}
  \end{case}
\end{proof}

Finally, we prove one final lemma and the noninterference theorem.  The lemma
shows that if an expression is typed with a low security label, then both
projections (so the value in either run of the program) are equivalent.

\begin{lemma}
  \label{lem:final_support}
  Let $H$ be an upward-closed subset of the label lattice $\mathcal{L}$.  Let $l
  \not\in H$.  If, using $H$ for the set of high labels, $\typeRule{
  }{e}{\textsf{int}^l}$ and $e \to^* v$ then $\lift{v}_1 = \lift{v}_2$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:subj_red} and \ref{lem:value}, we know that $\typeRule{
  }{v}{\textsf{int}^l}$ holds.  Since the type is $\textsf{int}^l$, we know that
  $v$ is either $k$ or $< k_1 | k_2 >$.  However, we know that if it were the
  latter, then by \textsc{V-Bracket} this would imply there is an $l' \leq l$
  such that $l' \in H$, a contradiction.  Thus, $v$ must be of the form $k$
  which is the same under either projection.
\end{proof}

The noninteference theorem shows that if we have an expression that is typed
with a low label, then replacing any bracketed value in the expression with
either projection will result in the same value for the overall expression.  In
other words, if we vary any high security item in a low security expression, the
value must not be affected.

\begin{thm}[Noninterference]
  Choose $l, h \in \mathcal{L}$ such that $h \not\leq l$.  Let $h \guards t$.
  Assume $\typeRule{(x \mapsto t)}{e}{\textsf{int}^l}$, where $e$is a \langName
  expression.  If, for all $i \in \{1, 2\}$, $\typeRule{ }{v_i}{t}$ and $e[x
  \Leftarrow v_i] \to^* v_i'$ hold, then $v_1' = v_2'$.
\end{thm}
\begin{proof}
  Let $H$ be the upward closure of $\{h\}$ and $v = < v_1 | v_2 >$, since other
  $v$ would be immediately uninteresting.  By \textsc{V-Bracket}, we know that
  $\typeRule{ }{v}{t}$ holds given the assumptions.
  By Lemma~\ref{lem:substitution}, we have $\typeRule{ }{e[x \Leftarrow
  v]}{\textsf{int}^l}$.  By Lemma~\ref{lem:final_support}, we know that
  $\lift{e[x \Leftarrow v]}_i = e[x \Leftarrow \lift{v}_i]$, which under the
  current assumptions reduces to $v_i$.  By Lemma~\ref{lem:completeness} we know
  that there is an answer $a$ such that $e[x \Leftarrow v] \to^* a$.  By
  Lemma~\ref{lem:soundness}, $\lift{a}_i = v_i'$ for all $i$ which means that
  $a$ is a value.  Then, we know by Lemma~\ref{lem:final_support} that $v_1' =
  v_2'$.
\end{proof}

\section{Mechanizing Proofs}
\label{sec:mechanizing}

As mentioned above, we unfortunately were unable to complete our noninterference
proof in Coq by the time of this report.  Given more time, we are confident that
this could be completed however.  So far, we have proven the first few lemmas
described in Section~\ref{sec:proof}.  This was much more difficult than the
short natural language proofs would suggest, due to a combination of the
stricter format required by Coq and the number of items that are elided in the
proofs because they were considered trivial or obvious.

We found that the process of mechanizing the lemmas that we proved was a useful
exercise in checking our understanding of our language, statements, and the work
of Simonet and Pottier which we based our approach off of.  We found ourselves
often surprised by the number of items that were elided by the proofs in the
paper.  For example, the proof of Lemma~\ref{lem:soundness} is one line of
natural languae but turned out to be 40 lines of Coq code, not including all of
the supporting definitions and rules.

Our proof of Lemma~\ref{lem:soundness} actually turned out to be instructive
because it forced us to recognize that the original formulation in Simonet and
Pottier's paper on \origLang~\cite{InfoFlowML} wasn't quite correct.
Specifically, it is entirely possible that a step in the operational semantics
does not translate to a step in the operational semantics under either
projection, as in the case of the \ref{eq:lift-app} rule, where $\lift{e}_i$ and
$\lift{e'}_i$ are identical.  Luckily, we are fairly confident, given that we
were still able to prove Lemma~\ref{lem:stuck_bracket} despite this change, that
this is not a critical error in the original paper.

\todo{More.}

\section{Related Work}
\label{sec:related}

This project is related to a variety of previous work, specifically in the realm
of security and verified proofs and programs.  We are following in the footsteps
of verified languages and compilers, which focus on writing programs and
language specs that are verified to have the properties the authors want by
providing the proofs of these properties on the
definitions~\cite{strecker2002formal,leinenbach2005towards,dave2003compiler,leroy2009formally,leroy2006formal,leroy2009formal,leroy2012compcert,chlipala2010verified,berghofer2004extracting}.
This has been a popular area, which is primarily focused on more mainstream
languages and compilers (such as C and Java).

Another related avenue of research has been the work on proof carrying code,
which involves a compiler producing a proof that the program satisfies some
property along with the compiled program, allowing a smaller trusted computing
base for security sensitive computing
scenarios~\cite{necula2002proof,necula1998design}.  Our goal was to make a step
towards producing a verifying compiler for a language with information flow
types like Jif or FlowCaml, which use a type system very similar to the one
presented in this paper for ensuring noninterference of
programs~\cite{InfoFlowML,myers1999jflow}.

\section{Future Work}
\label{sec:future}

\todo{Talk about stuff we still have to do for this to be a complete project.
Talk about expected problems and required techniques.  Talk about what we could
do once this project is completed and we could use it for other projects.}

\section{Conclusion}
\label{sec:conclusion}

In this paper, we present a simple information flow typed language \langName,
prove noninterference for the language, and discuss our experiences beginning to
mechanize this proof in Coq.  Although we did not complete our proof, we were
able to catch inaccuracies and subtleties that the proof we based our approach
on did not handle or explicitly cover.  This is the first step towards a
verified compiler for a language with information flow types such as Jif or
FlowCaml, which allows for a more trustworthy compiler and language definition,
by allowing users to verify the proofs in a proof assistant like Coq.  As far as
we know, a verified proof of noninterference for such a language has not been
implemented, let alone a verified compiler.  We are confident that, given more
time and a large amount of work, such a verified compiler could be realized for
a mature information flow language.

\section*{Acknowledgements}

We would like to thank Jon Sailor for chatting with us on the phone for hours to
help work through some of the more difficult problems we ran into using Coq.
Also, we would like to thank the authors of Software
Foundations~\cite{Pierce:sf}, which was the primary resource for learning Coq
for both authors.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
