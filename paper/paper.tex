\documentclass[a4paper]{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{float}
%\floatstyle{boxed}
%\restylefloat{figure}

\newcommand{\langName}[0]{TinyML\textsuperscript{2}}
\newcommand{\origLang}[0]{CoreML\textsuperscript{2}}
\newcommand{\typeRule}[3]{#1 \vdash #2 \colon #3}
\newcommand{\guards}[0]{\lhd}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem*{case}{Case}

\title{Towards a Mechanized Proof of Noninterference}
\author{Tom Magrino \and Matthew Milano}
\begin{document}

\maketitle

\abstract

In this paper we discuss our experience trying to mechanize a proof of
noninterference for a simple language with security labels, \langName.  Although
we did not complete the full noninterference proof because we ran out of time,
we were able to find small inaccuracies and subtleties in the proofs from the
paper we based our proof on.  We discuss what would be involved in completing
the proof and how this relates to other work.

\section{Introduction}

Verified systems have been growing in popularity recently with the rise of proof
assistants like Coq and NuPRL~\cite{coqart,nuprl}.  These systems allow a
programmer to write programs and have proofs, which are checked and compiled by
the system, which can assert various properties about the programs.  As we will
discuss in Section~\ref{sec:related}, these systems have been used to formalize,
prove correct, and implement systems that have verified properties.  This allows
for programmers to be more confident in their languages and programs, ensuring
that the properties they want are actually properties of their work.

Interestingly, as far as we know there has not been work to formalize and verify
a language, like Jif~\cite{myers1999jflow} or FlowCaml~\cite{simonet2003flow},
that has a type system for enforcing information flow security policies.  For
languages like these and other systems related to security, it is desirable for
the program to be accompanied with a proof of the security properties it
enforces.  Our goal is to make progress towards verifying the correctness of a
compiler for a language with information flow types that programmers will want
to use.

A verified compiler for a language like Jif would require a proof of
noninterference, which asserts that any program in the language will never
produce different outputs for low security items if only the high security input
values are varied.  Thus, in this paper we discuss our experience working
towards proving this theorem for a simple information flow type system as a
first step towards creating a verified information flow compiler.

Our language, \langName,  and proof are a simplified version of what is
presented in Simonet and Pottier's work on information flow for an ML-like
language, \origLang~\cite{InfoFlowML}.  This proof proceeds by designing a
language that includes values which represent two different alternatives,
representing the different values of high security items in two different
executions of the program.  The proof then becomes a matter of proving that if
the program is typed with a low security label, this does not produce a value
that could be different between two different executions of the program.

In this paper we will present our simplified language, \langName,
along with the semantics and type system (Section~\ref{sec:lang}).  We will then
present a natural language, human readable, proof of noninterference for the
language and discuss our experiences with mechanizing this proof in the Coq
proof assistant (Sections~\ref{sec:proof} and \ref{sec:mechanizing}).  Finally,
we will discuss related work, next steps, and conclude
(Sections~\ref{sec:related}, \ref{sec:future}, and \ref{sec:conclusion}).

\section{\langName}
\label{sec:lang}

Our toy language for proving noninterference, \langName, is a simplified version
of \origLang from Simonet and Pottier's paper~\cite{InfoFlowML}.  Since we had a
limited amount of time to work on this project, we limited ourselves to a subset
of the language that drops the following features:

\begin{itemize}
  \item References and associated memory operations.
  \item Paired values.
  \item Exceptions.
  \item Sequencing operations.
\end{itemize}

While the language becomes much much less interesting for actual programming, we
feel that these features do not fundamentally change the problem of proving
noninterference.  In order to mechanize a proof of noninterference for a
language closer to \origLang, it would require simply adding mechanized proofs
for the additional cases where appropriate.

\textbf{TODO: Talk about what the bracketed expressions and values are.}

Furthermore, primarily due to a matter of taste, we decided to replace the
\textsf{case} construct from \origLang for an \textsf{if} construct, which
evaluates the first expression if the test evaluates to 1 and evaluates to the
second expression otherwise.

Through these changes, our language has the syntax shown in
Figure~\ref{fig:syntax}.  As shown, final states, answers, in the language are
now simple values because there are no exceptions.

\begin{figure}[h!]
  \begin{align}
    v & ::= x \: | \: k \: | \: \textsf{fix} f . \lambda x . e \tag{values} \: |
    \: <v | v> \\
    a & ::= v \tag{answers} \: | \: <a | a> \\
    e & ::= a \: | \: v v \: | \: \textsf{if } v \: e \: e \: | \: \textsf{let
    } x := v \textsf{ in } e \tag{expressions} \: | \: <e | e> \\
  \end{align}
  \caption{Syntax of \langName}
  \label{fig:syntax}
\end{figure}

In the following two subsections, we introduce the operational semantics and
type system for the language.

\subsection{Operational Semantics}

\langName has an operational semantics that should be familiar to the reader who
has seen a single step semantics for a basic lambda calculus.  The interesting
additions are the same as those in \origLang, where there are additional rules
for handling the bracketed values.

\textbf{TODO: Talk about what the rules do at a high level.}

\begin{figure}[h!]
  Basic reductions
  \begin{align}
    (\textsf{fix} f . \lambda x . e) v
    \: \to \: &
    e[x \Leftarrow v][f \Leftarrow \textsf{fix} f . \lambda x . e]
    \tag{$\beta$}
    \label{eq:beta}
    \\
    \textsf{if } 1 \: e_1 \textsf { } e_2
    \: \to \: &
    e_1
    \tag{if-true}
    \label{eq:if-true}
    \\
    \textsf{if } (k \neq 1) \textsf { } e_1 \textsf { } e_2
    \: \to \: &
    e_2
    \tag{if-false}
    \label{eq:if-false}
    \\
    \textsf{let }  x := v \textsf{ in } e
    \: \to \: &
    e[x \Leftarrow v]
    \tag{let}
    \label{eq:let}
  \end{align}

  Lifting
  \begin{align}
    < v_1 | v_2 > v
    \: \to \: &
    < v_1 \lift{v}_1 | v_2 \lift{v}_2 >
    \tag{lift-app}
    \label{eq:lift-app}
    \\
    \textsf{if } < v_1 | v_2 > \: e_1 \: e_2
    \: \to \: &
    < \textsf{if } v_1 \: \lift{e_1}_1 \: \lift{e_2}_1 \: |
    \textsf{ if } v_2 \: \lift{e_1}_2 \: \lift{e_2}_2 >
    \tag{lift-if}
    \label{eq:lift-if}
    \\
    &
    \infer*
    {
    e_1 \to e_1' \\
    }
    {
    <e_1 | e_2> \: \to \: <e_1' | e_2>
    }
    \tag{bracket-left}
    \label{eq:bracket-left}
    \\
    &
    \infer*
    {
    e_2 \to e_2' \\
    }
    {
    <e_1 | e_2> \: \to \: <e_1 | e_2'>
    }
    \tag{bracket-right}
    \label{eq:bracket-right}
  \end{align}
  \caption{Operational semantics for \langName.}
  \label{fig:operational_semantics}
\end{figure}

\subsection{Type System}

\langName has a very simple type system, including only integers and lambda
abstractions, which include fixpoints by default, along with appropriate
security labels for both.  In \langName, security labels specify confidentiality
policies, specifying what other data the labelled data can affect.\footnote{It is
not difficult to imagine how to extend our system to include integrity labels.
However, for the sake of simplicity, we decided to concern ourselves with only
confidentiality at first}  Data can only be affected by items at the same label
or lower (so high data can not affect low labelled data).

The language's type system includes subtyping, which allows data that have a
lower label to flow into higher labelled data.  The rules for subtyping are
given in Figure~\ref{fig:subtype_rules}.  Rule \textsc{S-Int} states that
integers are subtypes of integers with equivalent or higher labels in the label
lattice.  Similarly, rule \textsc{S-Abs} gives the standard subtyping
relationship for functions along with the same label relation.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[S-Int]
    {
    l \leq l'
    }
    {
    \textsf{int}^l \leq \textsf{int}^{l'}
    }

    \infer[S-Abs]
    {
    t_{in}' \leq t_{in} \\
    t_{out} \leq t_{out}' \\
    l \leq l'
    }
    {
    (t_{in} \to t_{out})^l \leq (t_{in}' \to t_{out}')^{l'}
    }
  \end{mathpar}
  \caption{Rules for subtyping in \langName.}
  \label{fig:subtype_rules}
\end{figure}

For the sake of being able to discuss how strong labels are, we follow the
example of Simonet and Pottier~\cite{InfoFlowML} and define a ``guards''
relation between labels and types, denoted $l \guards t$, which states that the
label $l$ is at least as restrictive as the label on the type $t$.  In other
words, this requires that the type has at least $l$ for it's security label.
The two rules regarding this relationships for both types in our language are
given in Figure~\ref{fig:guard_rules}.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards \textsf{int}^{l'}
    }

    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards (* \to *)^{l'}
    }
  \end{mathpar}
  \caption{Rules for labels guarding types in \langName.}
  \label{fig:guard_rules}
\end{figure}

Figure~\ref{fig:value_types} includes typing judgements for values and
Figure~\ref{fig:expr_types} includes typing judgements for expressions.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[V-Int]
    { }
    {\typeRule{\Gamma}{k}{\textsf{int}^{*}}}

    \infer[V-Var]
    {t \in \Gamma(x)}
    {\typeRule{\Gamma}{x}{t}}

    \infer[V-Abs]
    {\typeRule{pc, \Gamma[x \mapsto t'][f \mapsto (t \to t')^l]}{e}{t}}
    {\typeRule{\Gamma}{\textsf{fix} f . \lambda x . e}{(t \to t')^l}}

    \infer[V-Bracket]
    {
    \typeRule{\Gamma}{v_1}{t} \\
    \typeRule{\Gamma}{v_2}{t} \\
    l \in H \\
    l \guards t
    }
    {\typeRule{\Gamma}{<v_1 | v_2>}{t}}

    \infer[V-Sub]
    {
    \typeRule{\Gamma}{v}{t'} \\
    t' \leq t
    }
    {\typeRule{\Gamma}{v}{t}}
  \end{mathpar}
  \caption{Typing judgements for values in \langName.}
  \label{fig:value_types}
\end{figure}

\begin{figure}[h!]
  \begin{mathpar}
    \infer[E-Value]
    {
    \typeRule{\Gamma}{v}{t}
    }
    {
    \typeRule{*, \Gamma}{v}{t}
    }

    \infer[E-App]
    {
    \typeRule{\Gamma}{v_1}{(t' \to t)^l} \\
    \typeRule{\Gamma}{v_2}{t'} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{v_1 v_2}{t}
    }

    \infer[E-If]
    {
    \typeRule{pc, \Gamma}{e_{test}}{\textsf{int}^l} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{true}}{t} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{false}}{t} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{\textsf{if } e_{test} \: e_{true} \: e_{false}}{t}
    }

    \infer[E-Let]
    {
    \typeRule{\Gamma}{v}{s} \\
    \typeRule{pc, \Gamma[x \mapsto s]}{e}{t} \\
    }
    {
    \typeRule{pc, \Gamma}{\textsf{let } x := s \textsf{ in } e}{t}
    }

    \infer[E-Sub]
    {
    \typeRule{pc, \Gamma}{e}{t'} \\
    t' \leq t
    }
    {
    \typeRule{pc, \Gamma}{e}{t}
    }

    \infer[E-Bracket]
    {
    \typeRule{pc \sqcup pc', \Gamma}{e_1}{t} \\
    \typeRule{pc \sqcup pc', \Gamma}{e_2}{t} \\
    pc' \in H \\
    pc' \guards t
    }
    {
    \typeRule{pc, \Gamma}{<e_1 | e_2>}{t}
    }
  \end{mathpar}
  \caption{Typing judgements for expressions in \langName.}
  \label{fig:expr_types}
\end{figure}

\textbf{TODO: Talk more about the rules and what they're doing.  Specifically,
discuss what the heck H and pc are doing.}

\section{Proof of Noninterference}
\label{sec:proof}

Before discussing the task of mechanizing a noninterference proof for \langName,
it is useful to first view what the natural language proof would look like
first.  We first start by proving some supporting lemmas about the language's
semantics and type system, and finish with a proof of noninterference for the
language.  Since \langName is a stripped down version of \origLang, the proofs
will look like a simplified version of the proofs found in Pottier and Simonet's
paper~\cite{InfoFlowML}.

\textbf{TODO: Add in text between lemmas and theorems discussing what each one
is at a high level.}

\begin{lemma}[Soundness]
  \label{lem:soundness}
  Let $i \in \{1, 2\}$. If $e \to e'$, then $\lift{e}_i \to^*
  \lift{e'}_i$.\footnote{Notice that this is not the same statement as the
  Soundness lemma in Simonet and Pottier's paper~\cite{InfoFlowML}, which does
  not give a variable number of steps for the conclusion.  We will discuss this
  change in Section~\ref{sec:mechanizing}.}
\end{lemma}
\begin{proof}
  This can be seen by examining each of the operational semantics rules in
  Figure~\ref{fig:operational_semantics}.
\end{proof}

\begin{lemma}
  \label{lem:stuck_bracket}
  If $e$ is stuck, then $\lift{e}_i$is stuck for some $i \in \{1, 2\}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $e$.

  \begin{case}[$e = v$]
    In this case, $e$ is not stuck.
  \end{case}

  \begin{case}[$e = v_1 v_2$]
    If $e$ is stuck and is an application, this means that neither
    \ref{eq:beta} nor \ref{eq:lift-app} applies.  This means that $v_1$ can
    neither be a fixpoint function or some bracketed value.  As a result,
    $\lift{v_1}_i$ can not be a fixpoint function, and so it is stuck.
  \end{case}

  \begin{case}[$e = \textsf{ if } v \: e_1 \: e_2$ or $e =
    \textsf{ let } x := v \textsf{ in } e$]
    These are similar to the previous case.  The value $v$ can not be an integer
    and so the lifted version of $v$ can not be an integer, meaning the lifted
    expression is also stuck.
  \end{case}

  \begin{case}[$e = < e_1 | e_2 >$]
    Since $e$ is stuck, then by \ref{eq:bracket-left} and \ref{eq:bracket-right}
    we know that both $e_1$ and $e_2$ must be stuck.  Since $e$ is not an
    answer, we know either $e_1$ or $e_2$ must not be an answer and, as a
    result, stuck.
  \end{case}
\end{proof}

\begin{lemma}[Completeness]
  \label{lem:completeness}
  Assume $\lift{e}_i \to^* a_i$ for all $i \in \{1, 2\}$.  Then, there exists an
  answer $a$ such that $e \to^* a$.
\end{lemma}
\begin{proof}
  \textbf{TODO}
\end{proof}

\begin{lemma}
  \label{lem:guard_subtype}
  If $l' \leq l$ and $l \guards t$ and $t \leq t'$, then $l' \guards t'$.
\end{lemma}
\begin{proof}
  $l \guards t$ is equivalent to $l \leq level(t)$ where $level$ is a function
  that takes a type and returns the label on that type.  It's simple to see that
  $level$ is covariant in its argument.  The result follows.
\end{proof}

\begin{lemma}[Weakening]
  \label{lem:weakening}
  $pc' \leq pc$ and $\typeRule{pc, \Gamma}{e}{t}$ imply $\typeRule{pc',
  \Gamma}{e}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\typeRule{pc, \Gamma}{e}{t}$.  By the
  monotonicity of $\sqcup$, rule \textsc{V-Sub}, Lemma~\ref{lem:guard_subtype},
  and the inductive hypothesis, it can be checked that the premise remains valid
  when $pc$ is lowered.
\end{proof}

\begin{lemma}[Projection]
  \label{lem:projection}
  Let $i \in \{1, 2\}$.  If $\typeRule{\Gamma}{v}{t}$ then
  $\typeRule{\Gamma}{\lift{v}_i}{t}$.  If $\typeRule{pc, \Gamma}{e}{t}$ then
  $\typeRule{pc, \Gamma}{\lift{e}_i}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation for $v$ and $e$.  The only interesting case is
  that of \textsc{E-Bracket}, since other cases end up either being trivial or
  using the inductive hypothesis for a case of \textsc{E-Bracket}.  The
  expression is $<e_1 | e_2>$.  Since $pc \sqcup pc' \leq pc$, by
  Lemma~\ref{lem:weakening} and the inductive hypothesis, we can prove the
  typing judgements for both branches.
\end{proof}

\begin{lemma}[Guard]
  \label{lem:guard}
  If $\typeRule{\Gamma}{< v_1 | v_2 >}{t}$ then there exists $pc' \in H$ s.t.
  $pc' \guards t$.
\end{lemma}
\begin{proof}
  Through Lemma~\ref{lem:guard_subtype}, we can see that we can always construct
  a typing derivation that does not end with \textsc{V-Sub}.  As a result, the
  derivation can always end with \textsc{V-Bracket}, which has the premises $pc'
  \in H$ and $pc' \guards t$.
\end{proof}

\begin{lemma}[Substitution]
  \label{lem:stuck_bracket}
  Assume $\typeRule{ }{v}{s}$.  Then, $\typeRule{\Gamma[x \mapsto s]}{v'}{t}$
  implies $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.  Also $\typeRule{pc,
  \Gamma[x \mapsto s]}{e}{t}$ implies $\typeRule{pc, \Gamma}{e[x \Leftarrow
  v]}{t}$.
\end{lemma}
\begin{proof}
  We can prove both statements by induction on the typing derivation for $v'$
  and $e$.  In this proof, we focus only on a subset of the cases.

  \begin{case}[\textsc{V-Int}]
    This is trivial, since $x$ does not get substituted in $v'$ and so the
    statement becomes a tautology.
  \end{case}

  \begin{case}[\textsc{V-Var}]
    If $v'$ is $x$, then we are in the case where $s \in t$.  Thus, we can
    conclude that given $\typeRule{ }{v}{s}$, $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ by \textsc{V-Var}.  Since $v'[x \Leftarrow v] = v$, we can
    conclude $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.

    Otherwise, we are in the case where $v'$ is some variable $y \neq x$.
    Then, given that $v'[x \Leftarrow v] = v' = y$ and since $\Gamma(y) =
    \Gamma[x \mapsto s]$, we can see that $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ implies that $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Abs}]
    The premise in this case becomes $\typeRule{pc, \Gamma[x \mapsto s][y
    \mapsto t'][f \mapsto (t' \to t'')^l]}{e'}{t''}$.

    Let us assume that $x$, $f$, and $y$ are distinct, since otherwise this
    would reduce to a similar situation to that of \textsc{V-Var} when the
    variable substitution leaves $v'$ unchanged, which is trivial.  Since they
    are distinct, $\Gamma[x \mapsto s][y \mapsto t'][f \mapsto (t' \to t'')^l]$
    is equivalent to $\Gamma[y \mapsto t'][f \mapsto (t' \to t'')^l][x \mapsto
    s]$ and so we can apply the inductive hypothesis and \textsc{V-Abs} to show
    $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Bracket}]
    In this case the premises are of the form $\typeRule{\Gamma[x \mapsto
    s]}{v'_i}{t}$.  By Lemma~\ref{lem:projection}, we know that
    $\typeRule{\Gamma}{v}{s}$ implies $\typeRule{\Gamma}{\lift{v}_i}{s}$.  By
    the inductive hypothesis, we can then say that $\typeRule{\Gamma}{v'_i[x
    \Leftarrow v]}{t}$ holds.  Thus, we can apply \textsc{V-Bracket} to obtain
    $\typeRule{\Gamma}{<v'_1[x \Leftarrow v] | v'_2[x \Leftarrow v]>}{t}$,
    proving the statement.
  \end{case}

  \begin{case}[\textsc{V-Sub}, \textsc{E-Value}, \textsc{E-App}, \textsc{E-If},
    \textsc{E-Let}, \textsc{E-Sub}]
    Applying the inductive hypothesis on the premises and applying the
    associated rule proves these cases.
  \end{case}

  \begin{case}[\textsc{E-Bracket}]
    This case is similar to the case of \textsc{V-Bracket}.
    Lemma~\ref{lem:guard} allows us to apply \textsc{E-Bracket} where necessary.
  \end{case}
\end{proof}

\begin{lemma}
  Let $H$ be an upward-closed subset of the label lattice $\mathcal{L}$.  Let $l
  \not\in H$.  If, using $H$ for the set of high labels, $\typeRule{
  }{e}{\textsf{int}^l}$ and $e \to^* v$ then $\lift{v}_1 = \lift{v}_2$.
\end{lemma}
\begin{proof}
  \textbf{TODO}
\end{proof}

\begin{thm}[Noninterference]
  Choose $l, h \in \mathcal{L}$ such that $h \not\leq l$.  Let $h \guards t$.
  Assume $\typeRule{(x \mapsto t)}{e}{\textsf{int}^l}$, where $e$is a \langName
  expression.  If, for all $i \in \{1, 2\}$, $\typeRule{ }{v_i}{t}$ and $e[x
  \Leftarrow v_i] \to^* v_i'$ hold, then $v_1' = v_2'$.
\end{thm}
\begin{proof}
  \textbf{TODO}
\end{proof}

\section{Mechanizing Proofs}
\label{sec:mechanizing}

Talk about what did/should have been mechanized.  Talk about troubles and/or
interesting bits here.  Might point out here that we're fairly certain that we
found an inaccuracy in the original paper.

\section{Related Work}
\label{sec:related}

Discuss various references related to our project.

\section{Future Work}
\label{sec:future}

Talk about stuff we still have to do for this to be a complete project.  Talk
about expected problems and required techniques.  Talk about what we could do
once this project is completed and we could use it for other projects.

\section{Conclusion}
\label{sec:conclusion}

Summarize again what we covered, where we ended up, and where we'd like to go
next.

\section*{Acknowledgements}

We would like to thank Jon Sailor for chatting with us on the phone to help work
through some of the more difficult problems we ran into using Coq.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
