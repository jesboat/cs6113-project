\documentclass[a4paper]{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{float}
%\floatstyle{boxed}
%\restylefloat{figure}

\newcommand{\langName}[0]{TinyML\textsuperscript{2}}
\newcommand{\origLang}[0]{CoreML\textsuperscript{2}}
\newcommand{\typeRule}[3]{#1 \vdash #2 \colon #3}
\newcommand{\guards}[0]{\lhd}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem*{case}{Case}

\title{Towards a Mechanized Proof of Noninterference}
\author{Tom Magrino \and Matthew Milano}
\begin{document}

\maketitle

\abstract

Abstract goes here, summarize what this paper covers and what we ended up with.

\section{Introduction}

Introduce idea and outline what it will require us to do.  Explain where we're
starting from (Pottier and Simonet) at a high level.  Justify why this is an
interesting problem that needs tackling.

\section{Operational Semantics}

Outline the operational semantics of the baby language we developed.  Outline
any interesting similarities or differences between us and Pottier and Simonet.

\begin{figure}
  Basic reductions
  \begin{align}
    (\textsf{fix} f . \lambda x . e) v
    \textsf{ } \to \textsf{ } &
    e[x \Leftarrow v][f \Leftarrow \textsf{fix} f . \lambda x . e]
    \tag{$\beta$}
    \label{eq:beta}
    \\
    \textsf{if } 1 \textsf{ } e_1 \textsf { } e_2
    \textsf{ } \to \textsf{ } &
    e_1
    \tag{if-true}
    \label{eq:if-true}
    \\
    \textsf{if } (k \neq 1) \textsf { } e_1 \textsf { } e_2
    \textsf{ } \to \textsf{ } &
    e_2
    \tag{if-false}
    \label{eq:if-false}
    \\
    \textsf{let }  x := v \textsf{ in } e
    \textsf{ } \to \textsf{ } &
    e[x \Leftarrow v]
    \tag{let}
    \label{eq:let}
  \end{align}

  Lifting
  \begin{align}
    < v_1 | v_2 > v
    \textsf{ } \to \textsf{ } &
    < v_1 \lift{v}_1 | v_2 \lift{v}_2 >
    \tag{lift-app}
    \label{eq:lift-app}
    \\
    \textsf{if } < v_1 | v_2 > \textsf{ } e_1 \textsf{ } e_2
    \textsf{ } \to \textsf{ } &
    < \textsf{if } v_1 \textsf{ } \lift{e_1}_1 \textsf{ } \lift{e_2}_1 |
    \textsf{ if } v_2 \textsf{ } \lift{e_1}_2 \textsf{ } \lift{e_2}_2 >
    \tag{lift-if}
    \label{eq:lift-if}
    \\
    &
    \infer*
    {
    e_1 \to e_1' \\
    }
    {
    <e_1 | e_2> \textsf{ } \to \textsf{ } <e_1' | e_2>
    }
    \tag{bracket-left}
    \label{eq:bracket-left}
    \\
    &
    \infer*
    {
    e_2 \to e_2' \\
    }
    {
    <e_1 | e_2> \textsf{ } \to \textsf{ } <e_1 | e_2'>
    }
    \tag{bracket-right}
    \label{eq:bracket-right}
  \end{align}
  \caption{Operational semantics for \langName.}
  \label{fig:operational_semantics}
\end{figure}

\section{Type System}

\langName has a very simple type system, including only integers and lambda
abstractions, which include fixpoints by default, along with appropriate
security labels for both.  In \langName, security labels specify confidentiality
policies, specifying what other data the labelled data can affect.\footnote{It is
not difficult to imagine how to extend our system to include integrity labels.
However, for the sake of simplicity, we decided to concern ourselves with only
confidentiality at first}  Data can only be affected by items at the same label
or lower (so high data can not affect low labelled data).

The language's type system includes subtyping, which allows data that have a
lower label to flow into higher labelled data.  The rules for subtyping are
given in Figure~\ref{fig:subtype_rules}.  Rule \textsc{S-Int} states that
integers are subtypes of integers with equivalent or higher labels in the label
lattice.  Similarly, rule \textsc{S-Abs} gives the standard subtyping
relationship for functions along with the same label relation.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[S-Int]
    {
    l \leq l'
    }
    {
    \textsf{int}^l \leq \textsf{int}^{l'}
    }

    \infer[S-Abs]
    {
    t_{in}' \leq t_{in} \\
    t_{out} \leq t_{out}' \\
    l \leq l'
    }
    {
    (t_{in} \to t_{out})^l \leq (t_{in}' \to t_{out}')^{l'}
    }
  \end{mathpar}
  \caption{Rules for subtyping in \langName.}
  \label{fig:subtype_rules}
\end{figure}

For the sake of being able to discuss how strong labels are, we follow the
example of Simonet and Pottier~\cite{InfoFlowML} and define a ``guards''
relation between labels and types, denoted $l \guards t$, which states that the
label $l$ is at least as restrictive as the label on the type $t$.  In other
words, this requires that the type has at least $l$ for it's security label.
The two rules regarding this relationships for both types in our language are
given in Figure~\ref{fig:guard_rules}.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards \textsf{int}^{l'}
    }

    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards (* \to *)^{l'}
    }
  \end{mathpar}
  \caption{Rules for labels guarding types in \langName.}
  \label{fig:guard_rules}
\end{figure}

Figure~\ref{fig:value_types} includes typing judgements for values and
Figure~\ref{fig:expr_types} includes typing judgements for expressions.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[V-Int]
    { }
    {\typeRule{\Gamma}{k}{\textsf{int}^{*}}}

    \infer[V-Var]
    {t \in \Gamma(x)}
    {\typeRule{\Gamma}{x}{t}}

    \infer[V-Abs]
    {\typeRule{pc, \Gamma[x \mapsto t'][f \mapsto (t \to t')^l]}{e}{t}}
    {\typeRule{\Gamma}{\textsf{fix} f . \lambda x . e}{(t \to t')^l}}

    \infer[V-Bracket]
    {
    \typeRule{\Gamma}{v_1}{t} \\
    \typeRule{\Gamma}{v_2}{t} \\
    l \in H \\
    l \guards t
    }
    {\typeRule{\Gamma}{<v_1 | v_2>}{t}}

    \infer[V-Sub]
    {
    \typeRule{\Gamma}{v}{t'} \\
    t' \leq t
    }
    {\typeRule{\Gamma}{v}{t}}
  \end{mathpar}
  \caption{Typing judgements for values in \langName.}
  \label{fig:value_types}
\end{figure}

\begin{figure}[h!]
  \begin{mathpar}
    \infer[E-Value]
    {
    \typeRule{\Gamma}{v}{t}
    }
    {
    \typeRule{*, \Gamma}{v}{t}
    }

    \infer[E-App]
    {
    \typeRule{\Gamma}{v_1}{(t' \to t)^l} \\
    \typeRule{\Gamma}{v_2}{t'} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{v_1 v_2}{t}
    }

    \infer[E-If]
    {
    \typeRule{pc, \Gamma}{e_{test}}{\textsf{int}^l} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{true}}{t} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{false}}{t} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{\textsf{if } e_{test} \textsf{ } e_{true} \textsf{ } e_{false}}{t}
    }

    \infer[E-Let]
    {
    \typeRule{\Gamma}{v}{s} \\
    \typeRule{pc, \Gamma[x \mapsto s]}{e}{t} \\
    }
    {
    \typeRule{pc, \Gamma}{\textsf{let } x := s \textsf{ in } e}{t}
    }

    \infer[E-Sub]
    {
    \typeRule{pc, \Gamma}{e}{t'} \\
    t' \leq t
    }
    {
    \typeRule{pc, \Gamma}{e}{t}
    }

    \infer[E-Bracket]
    {
    \typeRule{pc \sqcup pc', \Gamma}{e_1}{t} \\
    \typeRule{pc \sqcup pc', \Gamma}{e_2}{t} \\
    pc' \in H \\
    pc' \guards t
    }
    {
    \typeRule{pc, \Gamma}{<e_1 | e_2>}{t}
    }
  \end{mathpar}
  \caption{Typing judgements for expressions in \langName.}
  \label{fig:expr_types}
\end{figure}

\section{Proofs}

Before discussing the task of mechanizing a noninterference theorem for
\langName, it is useful to first view what the natural language proof would
look like first.  We first start by proving some supporting lemmas and finish
with a proof of noninterference for the language.  Since \langName is a stripped
down version of \origLang, the proofs will look like a simplified version of the
proofs found in Pottier and Simonet's paper~\cite{InfoFlowML}.

\begin{lemma}[Soundness]
  \label{lem:soundness}
  Let $i \in \{1, 2\}$. If $e \to e'$, then $\lift{e}_i \to^*
  \lift{e'}_i$.\footnote{Notice that this is not the same statement as the
  Soundness lemma in Simonet and Pottier's paper~\cite{InfoFlowML}, which does
  not give a variable number of steps for the conclusion.  We will discuss this
  change in Section~\ref{sec:mechanizing}.}
\end{lemma}
\begin{proof}
  This can be seen by examining each of the operational semantics rules in
  Figure~\ref{fig:operational_semantics}.
\end{proof}

\begin{lemma}
  \label{lem:stuck_bracket}
  If $e$ is stuck, then $\lift{e}_i$is stuck for some $i \in \{1, 2\}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $e$.

  \begin{case}[$e = v$]
    In this case, $e$ is not stuck.
  \end{case}

  \begin{case}[$e = v_1 v_2$]
    If $e$ is stuck and is an application, this means that neither
    \ref{eq:beta} nor \ref{eq:lift-app} applies.  This means that $v_1$ can
    neither be a fixpoint function or some bracketed value.  As a result,
    $\lift{v_1}_i$ can not be a fixpoint function, and so it is stuck.
  \end{case}

  \begin{case}[$e = \textsf{ if } v \textsf{ } e_1 \textsf{ } e_2$ or $e =
    \textsf{ let } x := v \textsf{ in } e$]
    These are similar to the previous case.  The value $v$ can not be an integer
    and so the lifted version of $v$ can not be an integer, meaning the lifted
    expression is also stuck.
  \end{case}

  \begin{case}[$e = < e_1 | e_2 >$]
    Since $e$ is stuck, then by \ref{eq:bracket-left} and \ref{eq:bracket-right}
    we know that both $e_1$ and $e_2$ must be stuck.  Since $e$ is not a final
    value, we know either $e_1$ or $e_2$ must not be a final value and, as a
    result, stuck.
  \end{case}
\end{proof}

\begin{lemma}[Completeness]
  \label{lem:completeness}
  Assume $\lift{e}_i \to^* a_i$ for all $i \in \{1, 2\}$.  Then, there exists a
  final value $a$ such that $e \to^* a$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  \label{lem:guard_subtype}
  If $l' \leq l$ and $l \guards t$ and $t \leq t'$, then $l' \guards t'$.
\end{lemma}
\begin{proof}
  $l \guards t$ is equivalent to $l \leq level(t)$ where $level$ is a function
  that takes a type and returns the label on that type.  It's simple to see that
  $level$ is covariant in its argument.  The result follows.
\end{proof}

\begin{lemma}[Weakening]
  \label{lem:weakening}
  $pc' \leq pc$ and $\typeRule{pc, \Gamma}{e}{t}$ imply $\typeRule{pc',
  \Gamma}{e}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\typeRule{pc, \Gamma}{e}{t}$.  By the
  monotonicity of $\sqcup$, rule \textsc{V-Sub}, Lemma~\ref{lem:guard_subtype},
  and the inductive hypothesis, it can be checked that the premise remains valid
  when $pc$ is lowered.
\end{proof}

\begin{lemma}[Projection]
  \label{lem:projection}
  Let $i \in \{1, 2\}$.  If $\typeRule{\Gamma}{v}{t}$ then
  $\typeRule{\Gamma}{\lift{v}_i}{t}$.  If $\typeRule{pc, \Gamma}{e}{t}$ then
  $\typeRule{pc, \Gamma}{\lift{e}_i}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation for $v$ and $e$.  The only interesting case is
  that of \textsc{E-Bracket}, since other cases end up either being trivial or
  using the inductive hypothesis for a case of \textsc{E-Bracket}.  The
  expression is $<e_1 | e_2>$.  Since $pc \sqcup pc' \leq pc$, by
  Lemma~\ref{lem:weakening} and the inductive hypothesis, we can prove the
  typing judgements for both branches.
\end{proof}

\begin{lemma}[Guard]
  \label{lem:guard}
  If $\typeRule{\Gamma}{< v_1 | v_2 >}{t}$ then there exists $pc' \in H$ s.t.
  $pc' \guards t$.
\end{lemma}
\begin{proof}
  Through Lemma~\ref{lem:guard_subtype}, we can see that we can always construct
  a typing derivation that does not end with \textsc{V-Sub}.  As a result, the
  derivation can always end with \textsc{V-Bracket}, which has the premises $pc'
  \in H$ and $pc' \guards t$.
\end{proof}

\begin{lemma}[Substitution]
  \label{lem:stuck_bracket}
  Assume $\typeRule{ }{v}{s}$.  Then, $\typeRule{\Gamma[x \mapsto s]}{v'}{t}$
  implies $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.  Also $\typeRule{pc,
  \Gamma[x \mapsto s]}{e}{t}$ implies $\typeRule{pc, \Gamma}{e[x \Leftarrow
  v]}{t}$.
\end{lemma}
\begin{proof}
  We can prove both statements by induction on the typing derivation for $v'$
  and $e$.  In this proof, we focus only on a subset of the cases.

  \begin{case}[\textsc{V-Int}]
    This is trivial, since $x$ does not get substituted in $v'$ and so the
    statement becomes a tautology.
  \end{case}

  \begin{case}[\textsc{V-Var}]
    If $v'$ is $x$, then we are in the case where $s \in t$.  Thus, we can
    conclude that given $\typeRule{ }{v}{s}$, $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ by \textsc{V-Var}.  Since $v'[x \Leftarrow v] = v$, we can
    conclude $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.

    Otherwise, we are in the case where $v'$ is some variable $y \neq x$.
    Then, given that $v'[x \Leftarrow v] = v' = y$ and since $\Gamma(y) =
    \Gamma[x \mapsto s]$, we can see that $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ implies that $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Abs}]
    The premise in this case becomes $\typeRule{pc, \Gamma[x \mapsto s][y
    \mapsto t'][f \mapsto (t' \to t'')^l]}{e'}{t''}$.

    Let us assume that $x$, $f$, and $y$ are distinct, since otherwise this
    would reduce to a similar situation to that of \textsc{V-Var} when the
    variable substitution leaves $v'$ unchanged, which is trivial.  Since they
    are distinct, $\Gamma[x \mapsto s][y \mapsto t'][f \mapsto (t' \to t'')^l]$
    is equivalent to $\Gamma[y \mapsto t'][f \mapsto (t' \to t'')^l][x \mapsto
    s]$ and so we can apply the inductive hypothesis and \textsc{V-Abs} to show
    $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Bracket}]
    In this case the premises are of the form $\typeRule{\Gamma[x \mapsto
    s]}{v'_i}{t}$.  By Lemma~\ref{lem:projection}, we know that
    $\typeRule{\Gamma}{v}{s}$ implies $\typeRule{\Gamma}{\lift{v}_i}{s}$.  By
    the inductive hypothesis, we can then say that $\typeRule{\Gamma}{v'_i[x
    \Leftarrow v]}{t}$ holds.  Thus, we can apply \textsc{V-Bracket} to obtain
    $\typeRule{\Gamma}{<v'_1[x \Leftarrow v] | v'_2[x \Leftarrow v]>}{t}$,
    proving the statement.
  \end{case}

  \begin{case}[\textsc{V-Sub}, \textsc{E-Value}, \textsc{E-App}, \textsc{E-If},
    \textsc{E-Let}, \textsc{E-Sub}]
    Applying the inductive hypothesis on the premises and applying the
    associated rule proves these cases.
  \end{case}

  \begin{case}[\textsc{E-Bracket}]
    This case is similar to the case of \textsc{V-Bracket}.
    Lemma~\ref{lem:guard} allows us to apply \textsc{E-Bracket} where necessary.
  \end{case}
\end{proof}

\begin{lemma}
  Let $H$ be an upward-closed subset of the label lattice $\mathcal{L}$.  Let $l
  \not\in H$.  If, using $H$ for the set of high labels, $\typeRule{
  }{e}{\textsf{int}^l}$ and $e \to^* v$ then $\lift{v}_1 = \lift{v}_2$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{thm}[Noninterference]
  Choose $l, h \in \mathcal{L}$ such that $h \not\leq l$.  Let $h \guards t$.
  Assume $\typeRule{(x \mapsto t)}{e}{\textsf{int}^l}$, where $e$is a \langName
  expression.  If, for all $i \in \{1, 2\}$, $\typeRule{ }{v_i}{t}$ and $e[x
  \Leftarrow v_i] \to^* v_i'$ hold, then $v_1' = v_2'$.
\end{thm}
\begin{proof}
  TODO
\end{proof}

\section{Mechanizing Proofs}
\label{sec:mechanizing}

Talk about what did/should have been mechanized.  Talk about troubles and/or
interesting bits here.  Might point out here that we're fairly certain that we
found an inaccuracy in the original paper.

\section{Related Work}

Discuss various references related to our project.

\section{Future Work}

Talk about stuff we still have to do for this to be a complete project.  Talk
about expected problems and required techniques.  Talk about what we could do
once this project is completed and we could use it for other projects.

\section{Conclusion}

Summarize again what we covered, where we ended up, and where we'd like to go
next.

\section*{Acknowledgements}

We would like to thank Jon Sailor for chatting with us on the phone to help work
through some of the more difficult problems we ran into using Coq.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
