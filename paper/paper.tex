\documentclass[a4paper]{article}
\usepackage{mathpartir}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{float}
%\floatstyle{boxed}
%\restylefloat{figure}

\newcommand{\langName}[0]{TinyML\textsuperscript{2}}
\newcommand{\origLang}[0]{CoreML\textsuperscript{2}}
\newcommand{\typeRule}[3]{#1 \vdash #2 \colon #3}
\newcommand{\guards}[0]{\lhd}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{Towards a Mechanized Proof of Noninterference}
\author{Tom Magrino \and Matthew Milano}
\begin{document}

\maketitle

\abstract

Abstract goes here, summarize what this paper covers and what we ended up with.

\section{Introduction}

Introduce idea and outline what it will require us to do.  Explain where we're
starting from (Pottier and Simonet) at a high level.  Justify why this is an
interesting problem that needs tackling.

\section{Operational Semantics}

Outline the operational semantics of the baby language we developed.  Outline
any interesting similarities or differences between us and Pottier and Simonet.

\section{Type System}

\langName has a very simple type system, including only integers and lambda
abstractions, which include fixpoints by default, along with appropriate
security labels for both.  In \langName, security labels specify confidentiality
policies, specifying what other data the labelled data can affect.\footnote{It is
not difficult to imagine how to extend our system to include integrity labels.
However, for the sake of simplicity, we decided to concern ourselves with only
confidentiality at first}  Data can only be affected by items at the same label
or lower (so high data can not affect low labelled data).

The language's type system includes subtyping, which allows data that have a
lower label to flow into higher labelled data.  The rules for subtyping are
given in Figure~\ref{fig:subtype_rules}.  Rule \textsc{S-Int} states that
integers are subtypes of integers with equivalent or higher labels in the label
lattice.  Similarly, rule \textsc{S-Abs} gives the standard subtyping
relationship for functions along with the same label relation.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[S-Int]
    {
    l \leq l'
    }
    {
    \textsf{int}^l \leq \textsf{int}^{l'}
    }

    \infer[S-Abs]
    {
    t_{in}' \leq t_{in} \\
    t_{out} \leq t_{out}' \\
    l \leq l'
    }
    {
    (t_{in} \to t_{out})^l \leq (t_{in}' \to t_{out}')^{l'}
    }
  \end{mathpar}
  \caption{Rules for subtyping in \langName.}
  \label{fig:subtype_rules}
\end{figure}

For the sake of being able to discuss how strong labels are, we follow the
example of Simonet and Pottier~\cite{InfoFlowML} and define a ``guards''
relation between labels and types, denoted $l \guards t$, which states that the
label $l$ is at least as restrictive as the label on the type $t$.  In other
words, this requires that the type has at least $l$ for it's security label.
The two rules regarding this relationships for both types in our language are
given in Figure~\ref{fig:guard_rules}.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards \textsf{int}^{l'}
    }

    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards (* \to *)^{l'}
    }
  \end{mathpar}
  \caption{Rules for labels guarding types in \langName.}
  \label{fig:guard_rules}
\end{figure}

Figure~\ref{fig:value_types} includes typing judgements for values and
Figure~\ref{fig:expr_types} includes typing judgements for expressions.

\begin{figure}[h!]
  \begin{mathpar}
    \infer[V-Int]
    { }
    {\typeRule{\Gamma}{k}{\textsf{int}^{*}}}

    \infer[V-Var]
    {\Gamma(x) = t}
    {\typeRule{\Gamma}{x}{t}}

    \infer[V-Abs]
    {\typeRule{pc, \Gamma[x \mapsto t'][f \mapsto (t \to t')^l]}{e}{t}}
    {\typeRule{\Gamma}{\textsf{fix} f . \lambda x . e}{(t \to t')^l}}

    \infer[V-Bracket]
    {
    \typeRule{\Gamma}{v_1}{t} \\
    \typeRule{\Gamma}{v_2}{t} \\
    l \in H \\
    l \guards t
    }
    {\typeRule{\Gamma}{<v_1 | v_2>}{t}}

    \infer[V-Sub]
    {
    \typeRule{\Gamma}{v}{t'} \\
    t' \leq t
    }
    {\typeRule{\Gamma}{v}{t}}
  \end{mathpar}
  \caption{Typing judgements for values in \langName.}
  \label{fig:value_types}
\end{figure}

\begin{figure}[h!]
  \begin{mathpar}
    \infer[E-Value]
    {
    \typeRule{\Gamma}{v}{t}
    }
    {
    \typeRule{*, \Gamma}{v}{t}
    }

    \infer[E-App]
    {
    \typeRule{\Gamma}{v_1}{(t' \to t)^l} \\
    \typeRule{\Gamma}{v_2}{t'} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{v_1 v_2}{t}
    }

    \infer[E-If]
    {
    \typeRule{pc, \Gamma}{e_{test}}{\textsf{int}^l} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{true}}{t} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{false}}{t} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{\textsf{if } e_{test} \textsf{ } e_{true} \textsf{ } e_{false}}{t}
    }

    \infer[E-Let]
    {
    \typeRule{\Gamma}{v}{s} \\
    \typeRule{pc, \Gamma[x \mapsto s]}{e}{t} \\
    }
    {
    \typeRule{pc, \Gamma}{\textsf{let } x := s \textsf{ in } e}{t}
    }

    \infer[E-Sub]
    {
    \typeRule{pc, \Gamma}{e}{t'} \\
    t' \leq t
    }
    {
    \typeRule{pc, \Gamma}{e}{t}
    }

    \infer[E-Bracket]
    {
    \typeRule{pc \sqcup pc', \Gamma}{e_1}{t} \\
    \typeRule{pc \sqcup pc', \Gamma}{e_2}{t} \\
    pc' \in H \\
    pc' \guards t
    }
    {
    \typeRule{pc, \Gamma}{<e_1 | e_2>}{t}
    }
  \end{mathpar}
  \caption{Typing judgements for expressions in \langName.}
  \label{fig:expr_types}
\end{figure}

\section{Proofs}

Before discussing the task of mechanizing a noninterference theorem for
\langName, it is useful to first view what the natural language proof would
look like first.  We first start by proving some supporting lemmas and finish
with a proof of noninterference for the language.  Since \langName is a stripped
down version of \origLang, the proof will look like a simplified version of the
proof found in Pottier and Simonet's paper~\cite{InfoFlowML}.

234101415

\begin{lemma}[Soundness]
  \label{lem:soundness}
  Let $i \in \{1, 2\}$. If $e \to e'$, then $\lift{e}_i \to \lift{e'}_i$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  \label{lem:stuck_bracket}
  If $e$ is stuck, then $\lift{e}_i$is stuck for some $i \in \{1, 2\}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Completeness]
  \label{lem:stuck_bracket}
  If $e$ is stuck, then $\lift{e}_i$is stuck for some $i \in \{1, 2\}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Substitution]
  \label{lem:stuck_bracket}
  Assume $\typeRule{ }{v}{s}$.  Then, $\typeRule{\Gamma[x \mapsto s]}{v'}{t}$
  implies $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.  Also $\typeRule{pc,
  \Gamma[x \mapsto s]}{e}{t}$ implies $\typeRule{pc, \Gamma}{e[x \Leftarrow
  v]}{t}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  Let $H$ be an upward-closed subset of the label lattice $\mathcal{L}$.  Let $l
  \not\in H$.  If, using $H$ for the set of high labels, $\typeRule{
  }{e}{\textsf{int}^l}$ and $e \to^* v$ then $\lift{v}_1 = \lift{v}_2$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{thm}[Noninterference]
  Choose $l, h \in \mathcal{L}$ such that $h \not\leq l$.  Let $h \guards t$.
  Assume $\typeRule{(x \mapsto t)}{e}{\textsf{int}^l}$, where $e$is a \langName
  expression.  If, for all $i \in \{1, 2\}$, $\typeRule{ }{v_i}{t}$ and $e[x
  \Leftarrow v_i] \to^* v_i'$ hold, then $v_1' = v_2'$.
\end{thm}
\begin{proof}
  TODO
\end{proof}

\section{Mechanizing Proofs}

Talk about what did/should have been mechanized.  Talk about troubles and/or
interesting bits here.  Might point out here that we're fairly certain that we
found an inaccuracy in the original paper.

\section{Related Work}

Discuss various references related to our project.

\section{Future Work}

Talk about stuff we still have to do for this to be a complete project.  Talk
about expected problems and required techniques.  Talk about what we could do
once this project is completed and we could use it for other projects.

\section{Conclusion}

Summarize again what we covered, where we ended up, and where we'd like to go
next.

\section*{Acknowledgements}

We would like to thank Jon Sailor from Facebook for helping us over the phone
work through some of the more difficult problems we ran into using Coq.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
