\documentclass[a4paper,twocolumn]{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
%\usepackage{float}
%\floatstyle{boxed}
%\restylefloat{figure}

\newcommand{\langName}[0]{TinyML\textsuperscript{2}}
\newcommand{\origLang}[0]{CoreML\textsuperscript{2}}
\newcommand{\typeRule}[3]{#1 \vdash #2 \colon #3}
\newcommand{\guards}[0]{\lhd}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}
\newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem*{case}{Case}

\title{Towards a Mechanized Proof of Noninterference}
\author{Tom Magrino \and Matthew Milano}
\begin{document}

\maketitle

\abstract

In this paper we discuss our experience trying to mechanize a proof of
noninterference for a simple language with security labels, \langName, based on
Pottier and Simonet's \origLang.  This
marks the first step towards writing a verified compiler for a language with
information flow types.  Although we did not complete the full noninterference
proof, we were able to find subtle inaccuracies in the \origLang proofs.  
We discuss what would be involved in completing the proof and how this 
relates to other work.

\section{Introduction}

Verified systems have been growing in popularity recently with the rise of proof
assistants like Coq and NuPRL~\cite{coqart,nuprl}.  
These systems allow programmers to construct proofs of properties of their programs which are checked and compiled by the system.  As we will
discuss in Section~\ref{sec:related}, these \emph{Proof Assistants} have been used to formalize,
prove correct, and implement systems with verified properties.  This increases Programmers' confidence in their languages and programs; to prove correctness of a function is a much stronger guarantee than simply testing functionality (or asserting correctness in the absence of tests).

The last decade has also seen a surge of research in languages which enforce information flow security, such as Jif~\cite{myers1999jflow} or FlowCaml~\cite{simonet2003flow}.  These languages provide features which programmers can use to enforce integrity and confidentiality of data as it is used throughout computations.

Given the growing popularity of Proof Assistants information-flow languages, we were surprised to discover 
that there has not been work done to formalize ad verify a language with a type systems which enforces information flow security policies.
These languages seem a natural choice for formal verification, as it is desirable for programs written in these languages to be accompanied with a proof of the security properties it enforces.
Our goal is to make progress towards verifying the correctness of a
compiler for a language with information flow types that programmers will want
to use.

The core theorem which distinguishes an information-flow language from a 
``normal'' programming language is the poof of noninterference, 
which asserts that across any two runs, every program in the language will never
produce different outputs for low security items if only the high security input
values are varied.  It is just this theorem we wish to prove in this paper; we
hope to learn through this effort of the unique challenges associated with
mechanizing proofs of information-flow languages.

Our language, \langName,  and proof are a simplified version of what is
presented in Simonet and Pottier's work on information flow for an ML-like
language, \origLang~\cite{InfoFlowML}.  The proof proceeds by designing a
core language, extending it with a term that represents a ``pair'' of 
values varied across two executions, and introducing these ``pairs'' of 
different values in context where the value would have a high-security label.
The proof then becomes a matter of showing that if
the program is typed with a low security label, it does not terminate
with a result that is an instance of one of these ``pairs.''

In this paper we will present our simplified language, \langName,
along with its semantics and type system (Section~\ref{sec:lang}).  We will then
present a natural language proof of noninterference for the
language and discuss our experiences with mechanizing this proof in the Coq
proof assistant (Sections~\ref{sec:proof} and \ref{sec:mechanizing}).  Finally,
we will discuss related work, next steps, and conclude
(Sections~\ref{sec:related}, \ref{sec:future}, and \ref{sec:conclusion}).

\section{\langName}
\label{sec:lang}

Our toy language for proving noninterference, \langName, is a simplified version
of \origLang from Simonet and Pottier's paper~\cite{InfoFlowML}.  Since we had a
limited amount of time to work on this project, we restricted ourselves to a subset
of the language that drops the following features:

\begin{itemize}
  \item References and associated memory operations.
  \item Value Tuples.
  \item Exceptions.
  \item Sequencing operations.
\end{itemize}

While the language becomes much more burdensome for the programmer, we
feel that these features do not fundamentally change the problem of proving
noninterference.  Mechanizing a proof of noninterference for a
language closer to \origLang would require simply adding mechanized proofs
for the additional cases where appropriate.

We also decided to replace the
\textsf{case} construct from \origLang with an \textsf{if} construct, which
evaluates the first expression if the test evaluates to 1 and evaluates to the
second expression otherwise.

\langName, like \origLang, includes angle bracketed expressions which represent
values or expressions which could differ between two runs of the program.  As we
will see when discussing the type system, this corresponds to values and
expressions that have high security labels on their types.

Through these changes, our language has the syntax shown in
Figure~\ref{fig:syntax}.  As shown, final states (answers) in the language are
now simple values because there are no exceptions.

\begin{figure}[t]
  \begin{align}
    v & ::= x \: | \: k \: | \: \textsf{fix} f . \lambda x . e \tag*{ } \\
    v' & ::= v \: | \: <v | v> \tag{values}\\
    a & ::= v \tag*{ } \\
    a' & ::= a \: | \: <a | a> \tag{answers} \\
    e & ::= a \: | \: v v \: | \: \textsf{if } v \: e \: e \: | \: \textsf{let
    } x := v \textsf{ in } e \tag*{ } \\
    e' & ::= e \: | \: <e | e> \tag{expressions}
  \end{align}
  \caption{Syntax of \langName.  The prime variants are the full class of
  expressions, values, and answers.  This construction avoids allowing nested
  branching values.}
  \label{fig:syntax}
\end{figure}

In the following two subsections, we introduce the operational semantics and
type system for the language.

\subsection{Operational Semantics}

\langName has an operational semantics reminiscent of single step semantics for a basic lambda calculus.  The interesting
additions are the same as those in \origLang -- additional rules
for handling the bracketed values.  The reduction rules for the semantics are
given in Figure~\ref{fig:operational_semantics}.

\begin{figure*}[t]
  Basic reductions
  \begin{align}
    (\textsf{fix} f . \lambda x . e) v
    \: \to \: &
    e[x \Leftarrow v][f \Leftarrow \textsf{fix} f . \lambda x . e]
    \tag{$\beta$}
    \label{eq:beta}
    \\
    \textsf{if } 1 \: e_1 \textsf { } e_2
    \: \to \: &
    e_1
    \tag{if-true}
    \label{eq:if-true}
    \\
    \textsf{if } (k \neq 1) \textsf { } e_1 \textsf { } e_2
    \: \to \: &
    e_2
    \tag{if-false}
    \label{eq:if-false}
    \\
    \textsf{let }  x := v \textsf{ in } e
    \: \to \: &
    e[x \Leftarrow v]
    \tag{let}
    \label{eq:let}
  \end{align}

  Lifting
  \begin{align}
    < v_1 | v_2 > v
    \: \to \: &
    < v_1 \lift{v}_1 | v_2 \lift{v}_2 >
    \tag{lift-app}
    \label{eq:lift-app}
    \\
    \textsf{if } < v_1 | v_2 > \: e_1 \: e_2
    \: \to \: &
    < \textsf{if } v_1 \: \lift{e_1}_1 \: \lift{e_2}_1 \: |
    \textsf{ if } v_2 \: \lift{e_1}_2 \: \lift{e_2}_2 >
    \tag{lift-if}
    \label{eq:lift-if}
    \\
    &
    \infer*
    {
    e_1 \to e_1' \\
    }
    {
    <e_1 | e_2> \: \to \: <e_1' | e_2>
    }
    \tag{bracket-left}
    \label{eq:bracket-left}
    \\
    &
    \infer*
    {
    e_2 \to e_2' \\
    }
    {
    <e_1 | e_2> \: \to \: <e_1 | e_2'>
    }
    \tag{bracket-right}
    \label{eq:bracket-right}
  \end{align}
  \caption{Operational semantics for \langName.}
  \label{fig:operational_semantics}
\end{figure*}

At a high level, these bracketed expressions are evaluated by evaluating one of
the branches, as shown in rules \ref{eq:bracket-left} and
\ref{eq:bracket-right}, or by expanding the brackets around the parent
expression, passing the appropriate branch of the bracketed subvalue to each
branch of the resulting expression, as shown in rules \ref{eq:lift-app} and
\ref{eq:lift-if}.  In these rules, we use the notation $\lift{x}_i$ to denote
the left ($i = 1$) or right ($i = 2$) branch of a bracketed expression or value
$x$.

We prove soundness and completeness lemmas for these rules in
Section~\ref{sec:proof}.

\subsection{Type System}

\langName has a very simple type system, including only integers and lambda
abstractions, which include fixpoints by default, along with appropriate
security labels for both, as shown in Figure~\ref{fig:types}.  In \langName,
security labels specify confidentiality policies, specifying what other data the
labelled data can affect.\footnote{It is not difficult to imagine how to extend
our system to include integrity labels.  However, for the sake of simplicity, we
decided to concern ourselves with only confidentiality at first}  Data can only
be affected by items at the same label or lower (so high data can not affect low
labelled data).

\begin{figure}[t]
  \begin{align*}
    t ::= int^l \: | \: (t \to t)^l
  \end{align*}
  \caption{Types for \langName}
  \label{fig:types}
\end{figure}

A reader familiar with the type system for \origLang will notice that our type
system does not include labels above the arrow in the function type, which would
normally give security bounds on side effects of the function, nor does it
include effect labels for exceptions.  These are dropped as a result of the
simplifications we made in defining \langName, since there are no side effects
or exceptions in the language.

The language's type system includes subtyping, which allows data that have a
lower label to flow into higher labelled data.  We use the notation $x \leq y$
to denote that $x$ is a subtype of $y$, whether both $x$ and $y$ are labels or
types (as long as both are the same kind of value).  The rules for subtyping are
given in Figure~\ref{fig:subtype_rules}.  Rule \textsc{S-Int} states that
integers are subtypes of integers with equivalent or higher labels in the label
lattice.  Similarly, rule \textsc{S-Abs} gives the standard subtyping
relationship for functions along with the same label relation.

\begin{figure}[t]
  \begin{mathpar}
    \infer[S-Int]
    {
    l \leq l'
    }
    {
    \textsf{int}^l \leq \textsf{int}^{l'}
    }

    \infer[S-Abs]
    {
    t_{in}' \leq t_{in} \\
    t_{out} \leq t_{out}' \\
    l \leq l'
    }
    {
    (t_{in} \to t_{out})^l \leq (t_{in}' \to t_{out}')^{l'}
    }
  \end{mathpar}
  \caption{Rules for subtyping in \langName.}
  \label{fig:subtype_rules}
\end{figure}

For the sake of being able to discuss how strong labels are in relation to a
type, we follow the example of Simonet and Pottier~\cite{InfoFlowML} and define
a ``guards'' relation between labels and types, denoted $l \guards t$, which
states that the label $l$ is at least as restrictive as the label on the type
$t$.  In other words, this requires that the type has at least $l$ for its
security label.  The two rules regarding this relationships for both types in
our language are given in Figure~\ref{fig:guard_rules}.

\begin{figure}[t]
  \begin{mathpar}
    \infer[G-Int]
    {
    l \leq l'
    }
    {
    l \guards \textsf{int}^{l'}
    }

    \infer[G-Abs]
    {
    l \leq l'
    }
    {
    l \guards (* \to *)^{l'}
    }
  \end{mathpar}
  \caption{Rules for labels guarding types in \langName.}
  \label{fig:guard_rules}
\end{figure}

Figure~\ref{fig:value_types} includes typing judgements for values in the
language, which are mostly straightforward with the exception of
\textsc{V-Bracket}, which we discuss below along with the type rules for
expressions.

\begin{figure*}[t]
  \begin{mathpar}
    \infer[V-Int]
    { }
    {\typeRule{\Gamma}{k}{\textsf{int}^{*}}}

    \infer[V-Var]
    {t \in \Gamma(x)}
    {\typeRule{\Gamma}{x}{t}}

    \infer[V-Abs]
    {\typeRule{pc, \Gamma[x \mapsto t'][f \mapsto (t \to t')^l]}{e}{t}}
    {\typeRule{\Gamma}{\textsf{fix} f . \lambda x . e}{(t \to t')^l}}

    \infer[V-Bracket]
    {
    \typeRule{\Gamma}{v_1}{t} \\
    \typeRule{\Gamma}{v_2}{t} \\
    l \in H \\
    l \guards t
    }
    {\typeRule{\Gamma}{<v_1 | v_2>}{t}}

    \infer[V-Sub]
    {
    \typeRule{\Gamma}{v}{t'} \\
    t' \leq t
    }
    {\typeRule{\Gamma}{v}{t}}
  \end{mathpar}
  \caption{Typing judgements for values in \langName.}
  \label{fig:value_types}
\end{figure*}

The typing rules for expressions in the language are given in
Figure~\ref{fig:expr_types}.  Unlike a typical typing judgment, we include an
additional piece of context information, the $pc$, which is a label that
describes what level of label can influence the control structure decisions to
reach the current expression in the program.  This is a standard extension for
languages with information flow types, like Jif.

The interesting rules in the type system are \textsc{V-Bracket},
\textsc{E-Bracket}, and \textsc{E-If}.  \textsc{E-If} is a standard rule for
information flow type systems, stating that the type determinations for each
branch must have a $pc$ equivalent to the security of the original $pc$ along
with the security of the label on the value in the test, $l$.

\textsc{V-Bracket} and \textsc{E-Bracket} both require that there exists a label
from the set $H$ which represents an upward closed sublattice of the labels in
the system representing what is considered to be ``high'' security for the
purposes of the proof of noninterference, discussed later.  These rules require
that the types of each branch of a bracketed value or expression can be typed
with a high security label.  Furthermore, \textsc{E-Bracket} requires that the
$pc$ of the subexpressions must be at least as high as this same label,
requiring that we treat everything in the subexpression as affected by high
security information.

\begin{figure*}[t]
  \begin{mathpar}
    \infer[E-Value]
    {
    \typeRule{\Gamma}{v}{t}
    }
    {
    \typeRule{*, \Gamma}{v}{t}
    }

    \infer[E-App]
    {
    \typeRule{\Gamma}{v_1}{(t' \to t)^l} \\
    \typeRule{\Gamma}{v_2}{t'} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{v_1 v_2}{t}
    }

    \infer[E-If]
    {
    \typeRule{pc, \Gamma}{e_{test}}{\textsf{int}^l} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{true}}{t} \\
    \typeRule{pc \sqcup l, \Gamma}{e_{false}}{t} \\
    l \guards t
    }
    {
    \typeRule{pc, \Gamma}{\textsf{if } e_{test} \: e_{true} \: e_{false}}{t}
    }

    \infer[E-Let]
    {
    \typeRule{\Gamma}{v}{s} \\
    \typeRule{pc, \Gamma[x \mapsto s]}{e}{t} \\
    }
    {
    \typeRule{pc, \Gamma}{\textsf{let } x := s \textsf{ in } e}{t}
    }

    \infer[E-Sub]
    {
    \typeRule{pc, \Gamma}{e}{t'} \\
    t' \leq t
    }
    {
    \typeRule{pc, \Gamma}{e}{t}
    }

    \infer[E-Bracket]
    {
    \typeRule{pc \sqcup pc', \Gamma}{e_1}{t} \\
    \typeRule{pc \sqcup pc', \Gamma}{e_2}{t} \\
    pc' \in H \\
    pc' \guards t
    }
    {
    \typeRule{pc, \Gamma}{<e_1 | e_2>}{t}
    }
  \end{mathpar}
  \caption{Typing judgements for expressions in \langName.}
  \label{fig:expr_types}
\end{figure*}

\section{Proof of Noninterference}
\label{sec:proof}

Before discussing the task of mechanizing a noninterference proof for \langName,
it is useful to first view the natural language proof.  We first start by proving some supporting lemmas about the language's
semantics and type system, and finish with a proof of noninterference for the
language.  Since \langName is a stripped down version of \origLang, the proofs
will look like a simplified version of the proofs found in Pottier and Simonet's
paper~\cite{InfoFlowML}.

We start with soundness and completeness lemmas for the operational semantics,
showing that this language can accurately describe the process of evaluating two
different runs of a language where bracketed expressions are high security
values.  Specifically, the image of a valid reduction of an expression is also a
valid reduction and if both runs of a program evaluate to an answer, then so can
the bracketed expression in \langName.

\begin{lemma}[Soundness]
  \label{lem:soundness}
  Let $i \in \{1, 2\}$. If $e \to e'$, then $\lift{e}_i \to^*
  \lift{e'}_i$.\footnote{Notice that this is not the same statement as the
  Soundness lemma in Simonet and Pottier's paper~\cite{InfoFlowML}, which does
  not give a variable number of steps for the conclusion.  We will discuss this
  change in Section~\ref{sec:mechanizing}.}
\end{lemma}
\begin{proof}
  This can be seen by examining each of the operational semantics rules in
  Figure~\ref{fig:operational_semantics}.
\end{proof}

\begin{lemma}
  \label{lem:stuck_bracket}
  If $e$ is stuck, then $\lift{e}_i$is stuck for some $i \in \{1, 2\}$.
\end{lemma}
\begin{proof}
  By induction on the structure of $e$.

  \begin{case}[$e = v$]
    In this case, $e$ is not stuck.
  \end{case}

  \begin{case}[$e = v_1 v_2$]
    If $e$ is stuck and is an application, this means that neither
    \ref{eq:beta} nor \ref{eq:lift-app} applies.  This means that $v_1$ can
    neither be a fixpoint function or some bracketed value.  As a result,
    $\lift{v_1}_i$ can not be a fixpoint function, and so it is stuck.
  \end{case}

  \begin{case}[$e = \textsf{ if } v \: e_1 \: e_2$ or $e =
    \textsf{ let } x := v \textsf{ in } e$]
    If $e$ is stuck and is an If-statement, then none of \ref{eq:lift-if}, \ref{eq:if-true}, and \ref{eq:if-false} applies. This means that $v$ can neither
    be an integer or some bracketed value.  As a result, $\lift{v}_i$ cannot
    be an integer, and so is stuck.
  \end{case}

  \begin{case}[$e = < e_1 | e_2 >$]
    Since $e$ is stuck, then by \ref{eq:bracket-left} and \ref{eq:bracket-right}
    we know that both $e_1$ and $e_2$ must be stuck.  Since $e$ is not an
    answer, we know either $e_1$ or $e_2$ must not be an answer and, as a
    result, stuck.
  \end{case}
\end{proof}

\begin{lemma}[Completeness]
  \label{lem:completeness}
  Assume $\lift{e}_i \to^* a_i$ for all $i \in \{1, 2\}$.  Then, there exists an
  answer $a$ such that $e \to^* a$.
\end{lemma}
\begin{proof}
  First, we establish that if $\lift{e}_i$ reduces to an answer in a finite
  number of steps, then $e$ does not have an infinite reduction sequence.  The
  only way this could occur is if $e$ was infinitely reduced over lift rules,
  because otherwise, since the only reductions on $e$ that correspond to 0
  reductions on either projection are lift reduction rules.  But as we can see
  from inspecting the lift reduction rules, we cannot continuously apply these
  rules exclusively.  Thus, we can conclude that $e$ does not have an infinite
  series of reduction steps that can be applied to it.

  As a result, we know that $e$ reduces to an answer, because otherwise it would
  be stuck and this would mean that one of the projections is also stuck by
  Lemma~\ref{lem:stuck_bracket}, a contradiction.  Thus, we know that if both
  projections step to an answer, so must the original expression.
\end{proof}

Next, we prove lemmas related to the type system.  We start with a lemma showing
that $\guards$ interacts well with subtyping and a weakening lemma, showing that
anything typed at a given $pc$ can be typed at a lower $pc'$ as well.

\begin{lemma}
  \label{lem:guard_subtype}
  If $l' \leq l$ and $l \guards t$ and $t \leq t'$, then $l' \guards t'$.
\end{lemma}
\begin{proof}
  $l \guards t$ is equivalent to $l \leq level(t)$ where $level$ is a function
  that takes a type and returns the label on that type.  It's simple to see that
  $level$ is covariant in its argument.  The result follows.
\end{proof}

\begin{lemma}[Weakening]
  \label{lem:weakening}
  $pc' \leq pc$ and $\typeRule{pc, \Gamma}{e}{t}$ imply $\typeRule{pc',
  \Gamma}{e}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\typeRule{pc, \Gamma}{e}{t}$.  By the
  monotonicity of $\sqcup$, rule \textsc{V-Sub}, Lemma~\ref{lem:guard_subtype},
  and the inductive hypothesis, it can be checked that the premise remains valid
  when $pc$ is lowered.
\end{proof}

We now prove a projection lemma, showing that if a top level expression or value
is well typed, so must either projection of that expression or value to one
program run or another.

\begin{lemma}[Projection]
  \label{lem:projection}
  Let $i \in \{1, 2\}$.  If $\typeRule{\Gamma}{v}{t}$ then
  $\typeRule{\Gamma}{\lift{v}_i}{t}$.  If $\typeRule{pc, \Gamma}{e}{t}$ then
  $\typeRule{pc, \Gamma}{\lift{e}_i}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation for $v$ and $e$.  The only interesting case is
  that of \textsc{E-Bracket}, since other cases end up either being trivial or
  using the inductive hypothesis for a case of \textsc{E-Bracket}.  The
  expression is $<e_1 | e_2>$.  Since $pc \sqcup pc' \leq pc$, by
  Lemma~\ref{lem:weakening} and the inductive hypothesis, we can prove the
  typing judgements for both branches.
\end{proof}

Below is a lemma showing that if a bracketed expression is well typed, then
there must exist a high security label to use for the types and $pc$ of both
branches.

\begin{lemma}[Guard]
  \label{lem:guard}
  If $\typeRule{\Gamma}{< v_1 | v_2 >}{t}$ then there exists $pc' \in H$ s.t.
  $pc' \guards t$.
\end{lemma}
\begin{proof}
  Through Lemma~\ref{lem:guard_subtype}, we can see that we can always construct
  a typing derivation that does not end with \textsc{V-Sub}.  As a result, the
  derivation can always end with \textsc{V-Bracket}, which has the premises $pc'
  \in H$ and $pc' \guards t$.
\end{proof}

Here we prove a standard substitution lemma for the type system.

\begin{lemma}[Substitution]
  \label{lem:substitution}
  Assume $\typeRule{ }{v}{s}$.  Then, $\typeRule{\Gamma[x \mapsto s]}{v'}{t}$
  implies $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.  Also $\typeRule{pc,
  \Gamma[x \mapsto s]}{e}{t}$ implies $\typeRule{pc, \Gamma}{e[x \Leftarrow
  v]}{t}$.
\end{lemma}
\begin{proof}
  We can prove both statements by induction on the typing derivation for $v'$
  and $e$.  In this proof, we focus only on a subset of the cases.

  \begin{case}[\textsc{V-Int}]
    This is trivial, since $x$ does not get substituted in $v'$ and so the
    statement becomes a tautology.
  \end{case}

  \begin{case}[\textsc{V-Var}]
    If $v'$ is $x$, then we are in the case where $s \in t$.  Thus, we can
    conclude that given $\typeRule{ }{v}{s}$, $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ by \textsc{V-Var}.  Since $v'[x \Leftarrow v] = v$, we can
    conclude $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.

    Otherwise, we are in the case where $v'$ is some variable $y \neq x$.
    Then, given that $v'[x \Leftarrow v] = v' = y$ and since $\Gamma(y) =
    \Gamma[x \mapsto s]$, we can see that $\typeRule{\Gamma[x \mapsto
    s]}{v'}{t}$ implies that $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Abs}]
    The premise in this case becomes $\typeRule{pc, \Gamma[x \mapsto s][y
    \mapsto t'][f \mapsto (t' \to t'')^l]}{e'}{t''}$.

    Let us assume that $x$, $f$, and $y$ are distinct, since otherwise this
    would reduce to a similar situation to that of \textsc{V-Var} when the
    variable substitution leaves $v'$ unchanged, which is trivial.  Since they
    are distinct, $\Gamma[x \mapsto s][y \mapsto t'][f \mapsto (t' \to t'')^l]$
    is equivalent to $\Gamma[y \mapsto t'][f \mapsto (t' \to t'')^l][x \mapsto
    s]$ and so we can apply the inductive hypothesis and \textsc{V-Abs} to show
    $\typeRule{\Gamma}{v'[x \Leftarrow v]}{t}$.
  \end{case}

  \begin{case}[\textsc{V-Bracket}]
    In this case the premises are of the form $\typeRule{\Gamma[x \mapsto
    s]}{v'_i}{t}$.  By Lemma~\ref{lem:projection}, we know that
    $\typeRule{\Gamma}{v}{s}$ implies $\typeRule{\Gamma}{\lift{v}_i}{s}$.  By
    the inductive hypothesis, we can then say that $\typeRule{\Gamma}{v'_i[x
    \Leftarrow v]}{t}$ holds.  Thus, we can apply \textsc{V-Bracket} to obtain
    $\typeRule{\Gamma}{<v'_1[x \Leftarrow v] | v'_2[x \Leftarrow v]>}{t}$,
    proving the statement.
  \end{case}

  \begin{case}[\textsc{V-Sub}, \textsc{E-Value}, \textsc{E-App}, \textsc{E-If},
    \textsc{E-Let}, \textsc{E-Sub}]
    Applying the inductive hypothesis on the premises and applying the
    associated rule proves these cases.
  \end{case}

  \begin{case}[\textsc{E-Bracket}]
    This case is similar to the case of \textsc{V-Bracket}.
    Lemma~\ref{lem:guard} allows us to apply \textsc{E-Bracket} where necessary.
  \end{case}
\end{proof}

The following lemma asserts that if a value is well typed, the expression
containing just that value is also well typed.

\begin{lemma}[Value]
  \label{lem:value}
  $\typeRule{pc}{v}{t}$ implies $\typeRule{ }{v}{t}$
\end{lemma}
\begin{proof}
  By induction on the proof of $\typeRule{pc}{v}{t}$.  The cases are either that
  we have \textsc{E-Value}, where we're done, \textsc{E-Sub}, in which case we
  apply the inductive hypothesis and the rule \textsc{V-Sub}, or we have
  \textsc{E-Bracket}, which is proved by the inductive hypothesis and
  \textsc{V-Bracket}.
\end{proof}

We also prove a subject reduction lemma, allowing us to assert that if an
expression is well typed and there is a reduction that can apply to it, then the
reduced form is also well typed, with the same type.

\begin{lemma}[Subject Reduction]
  \label{lem:subj_red}
  Let $e \to e'$.  Assume $\typeRule{pc}{e}{t}$ and $pc \in H$ for all $i \in
  \{1, 2\}$.  Then $\typeRule{pc}{e'}{t}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $e \to e'$.
  \begin{case}[$\beta$]
    In this case, $e = (\textsf{fix} f . \lambda x . e_0) v$.  In the premises
    of \textsc{E-App}, we have $\typeRule{ }{\textsf{fix} f . \lambda x .
    e_0}{(t' \to t)^l}$ and $\typeRule{ }{v}{t'}$.  The derivation of the
    function's type must end with \textsc{V-Abs} followed by some number of
    applications of \textsc{V-Sub}.  Applying Lemma~\ref{lem:weakening} and
    \textsc{E-Sub} to \text{V-Abs}'s premise gives $\typeRule{pc, (x \mapsto
    t''; f \mapsto \theta)}{e'}{t}$ for some $t''$ and $\theta$ which are
    subtypes of the function's type and the argument's type.  By \textsc{V-Sub},
    $\typeRule{ }{v}{t''}$ and $\typeRule{ }{\textsc{fix} f . \lambda x .
    e_0}{\theta}$.  Applying Lemma~\ref{lem:substitution} then gives
    $\typeRule{pc}{e'}{t}$.
  \end{case}

  \begin{case}[if]
    $e = \textsf{if } v \: e_1 \: e_2$ and $e' = e_i$ where $i$ is determined by
    the value of $v$.  \textsc{E-If}'s premises include $\typeRule{pc
    \sqcup l}{e_i}{t}$ for $i \in \{1, 2\}$ and $l \guards t$, which follows
    from Lemma~\ref{lem:weakening}.
  \end{case}

  \begin{case}[let]
    By \textsc{E-Let} and Lemma~\ref{lem:substitution}.
  \end{case}

  \begin{case}[lift-app]
    $e = <v_1 | v_2> v$ in this case.  Then \textsc{E-App}'s premises are
    $\typeRule{ }{<v_1 | v_2>}{(t' \to t)^l}$, $\typeRule{ }{v}{t'}$, and $l
    \guards t$.  Lemma~\ref{lem:projection} gives $\typeRule{ }{v_i}{(t' \to
    t)^l}$ and $\typeRule{ }{\lift{v}_i}{t'}$ for $i \in \{1, 2\}$.  Applying
    \textsc{E-App} gives $\typeRule{pc \sqcup l}{v_i\lift{v}_i}{t}$.  Applying
    Lemma~\ref{lem:guard} gives $l \in H$.  Since we have $l \guards t$, we can
    apply \textsc{E-Bracket} to get $\typeRule{ }{e'}{t}$.
  \end{case}

  \begin{case}[lift-if]
    $e = \text{if } <v_1 | v_2> \: e_1 \: e_2$ and $e' = e_i$ for some $i \in
    \{1, 2\}$ in this case.  Applying Lemma~\ref{lem:guard} to the first premise
    of \textsc{E-If} gives $l' \in H$ and $l' \guards t$.  Applying
    Lemma~\ref{lem:projection} to the initial premises of \textsc{E-If} and using
    the result and applying \textsc{E-If} gives $\typeRule{pc \sqcup l}{e_i}$.
    We can then apply \textsc{E-Bracket} to get the goal.
  \end{case}

  \begin{case}[bracket]
    In this case $e = <e_1 | e_2>$, and $e'$ is the result of taking a step in
    one side of the brackets.  $e$'s typing derivation must end with
    \textsc{E-Bracket}, which has premises $\typeRule{pc \sqcup pc'}{e_i}{t}$,
    $\typeRule{pc \sqcup pc'}{e_j}{t}$, $pc' \guards t$, and $pc' \in H$.  Since
    $pc' \in H$, we can apply the inductive hypothesis to get $\typeRule{pc
    \sqcup pc'}{e_i'}{t}$ and $\typeRule{pc \sqcup pc'}{e_j'}{t}$.  The result
    is then given by applying \textsc{E-Bracket}.
  \end{case}
\end{proof}

Finally, we prove one final lemma and the noninterference theorem.  The lemma
shows that if an expression is typed with a low security label, then both
projections (so the value in either run of the program) are equivalent.

\begin{lemma}
  \label{lem:final_support}
  Let $H$ be an upward-closed subset of the label lattice $\mathcal{L}$.  Let $l
  \not\in H$.  If, using $H$ for the set of high labels, $\typeRule{
  }{e}{\textsf{int}^l}$ and $e \to^* v$ then $\lift{v}_1 = \lift{v}_2$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:subj_red} and \ref{lem:value}, we know that $\typeRule{
  }{v}{\textsf{int}^l}$ holds.  Since the type is $\textsf{int}^l$, we know that
  $v$ is either $k$ or $< k_1 | k_2 >$.  However, we know that if it were the
  latter, then by \textsc{V-Bracket} this would imply there is an $l' \leq l$
  such that $l' \in H$, a contradiction.  Thus, $v$ must be of the form $k$
  which is the same under either projection.
\end{proof}

The noninterference theorem shows that if we have an expression that is typed
with a low label, then replacing any bracketed value in the expression with
either projection will result in the same value for the overall expression.  In
other words, if we vary any high security item in a low security expression, the
value must not be affected.

\begin{thm}[Noninterference]
  Choose $l, h \in \mathcal{L}$ such that $h \not\leq l$.  Let $h \guards t$.
  Assume $\typeRule{(x \mapsto t)}{e}{\textsf{int}^l}$, where $e$is a \langName
  expression.  If, for all $i \in \{1, 2\}$, $\typeRule{ }{v_i}{t}$ and $e[x
  \Leftarrow v_i] \to^* v_i'$ hold, then $v_1' = v_2'$.
\end{thm}
\begin{proof}
  Let $H$ be the upward closure of $\{h\}$ and $v = < v_1 | v_2 >$, since other
  $v$ would be immediately uninteresting.  By \textsc{V-Bracket}, we know that
  $\typeRule{ }{v}{t}$ holds given the assumptions.
  By Lemma~\ref{lem:substitution}, we have $\typeRule{ }{e[x \Leftarrow
  v]}{\textsf{int}^l}$.  By Lemma~\ref{lem:final_support}, we know that
  $\lift{e[x \Leftarrow v]}_i = e[x \Leftarrow \lift{v}_i]$, which under the
  current assumptions reduces to $v_i$.  By Lemma~\ref{lem:completeness} we know
  that there is an answer $a$ such that $e[x \Leftarrow v] \to^* a$.  By
  Lemma~\ref{lem:soundness}, $\lift{a}_i = v_i'$ for all $i$ which means that
  $a$ is a value.  Then, we know by Lemma~\ref{lem:final_support} that $v_1' =
  v_2'$.
\end{proof}

\section{Mechanizing Proofs}
\label{sec:mechanizing}

As mentioned above, we unfortunately were unable to complete our noninterference
proof in Coq by the time of this report.  Given more time, we are confident that
this could be completed however.  So far, we have proven the first few lemmas
described in Section~\ref{sec:proof} and defined relations for the operational
semantics and type system as presented in Section~\ref{sec:lang}.  This was much
more difficult than the short natural language proofs would suggest, due to a
combination of the stricter format required by Coq and the number of items that
are elided in the proofs because they were considered trivial or obvious.

We found that the process of mechanizing the lemmas that we proved was a useful
exercise in checking our understanding of our language, statements, and the work
of Simonet and Pottier which we based our approach off of.  We found ourselves
often surprised by the number of items that were elided by the proofs in the
paper.  For example, the proof of Lemma~\ref{lem:soundness} is one line of
natural language but turned out to be 40 lines of Coq code, not including all of
the supporting definitions and rules.

\subsection{Inaccuracies in the Original Proof}

We discovered a few small inaccuracies in \cite{InfoFlowML} by running into
issues when formalizing the proofs in Coq.  Listed below are the primary
corrections we were able to make.

\begin{description}
  \item[Non-nesting Brackets in Syntax]
    \hspace{0pt}
    
    As seen in Figure~\ref{fig:syntax}, we have a slightly different syntax
    structure for \langName from \origLang.  Specifically, we constructed
    values, answers, and expressions explicitly to not allow nesting of
    bracketed values.  This was not how the syntax figures in Simonet and
    Pottier's paper defined this, and as a result, we had trouble when our
    proofs depended on this explicit non-nesting property that was mentioned in
    the prose of their paper.  Realizing that our definitions did not disallow
    this by construction after running into issues in the proof, we were able to
    fix the definition producing what is in Figure~\ref{fig:syntax}.
    
  \item[Correction of the Soundness Lemma]
    \hspace{0pt}

    Proving our own version of Lemma~\ref{lem:soundness} actually turned out to
    be instructive because it forced us to recognize that the original
    formulation in Simonet and Pottier's paper on \origLang wasn't exactly
    correct as stated.  Specifically, it is entirely possible that a step in the
    operational semantics does not translate to a step in the operational
    semantics under either projection, as in the case of the \ref{eq:lift-app}
    rule, where $\lift{e}_i$ and $\lift{e'}_i$ are identical.  Luckily, we are
    fairly confident, given that we were still able to prove
    Lemma~\ref{lem:stuck_bracket} despite this change, that this is not a
    critical error in the original paper.
\end{description}

\todo{more?}

\section{Related Work}
\label{sec:related}

This project is related to a variety of previous work, specifically in the realm
of security and verified proofs and programs.  We are following in the footsteps
of verified languages and compilers, which focus on writing programs and
language specs that are verified to have the properties the authors want by
providing the proofs of these properties on the
definitions~\cite{strecker2002formal,leinenbach2005towards,dave2003compiler,leroy2009formally,leroy2006formal,leroy2009formal,leroy2012compcert,chlipala2010verified,berghofer2004extracting}.
This has been a popular area, which is primarily focused on more mainstream
languages and compilers (such as C and Java).

Another related avenue of research has been the work on proof carrying code,
which involves a compiler producing a proof that the program satisfies some
property along with the compiled program, allowing a smaller trusted computing
base for security sensitive computing
scenarios~\cite{necula2002proof,necula1998design}.  Our goal was to make a step
towards producing a verifying compiler for a language with information flow
types like Jif or FlowCaml, which use a type system very similar to the one
presented in this paper for ensuring noninterference of
programs~\cite{InfoFlowML,myers1999jflow}.

\section{Future Work}
\label{sec:future}

It is our hope that we could continue this work to complete a Coq proof of
noninterference for our language.  This would require proving the lemmas and
theorem in Section~\ref{sec:proof} along with various support lemmas and
definitions for things that are ``obvious'' in the natural language proofs.
It's unclear how long the remainder of the proof would take, but we are certain
that it is just a matter of time and effort.

Once a full Coq proof of noninterference exists, a next step would be to
integrate this proof and all of the related definitions into a verified type
checking program, which could be integrated into a verified compiler.  We
already know that a full verified compiler has been done for C, and this gives
us hope that it would be possible to implement something similar for a language
like Jif.

With a verified compiler for such a language, it would be possible to implement
a compiler that produced proofs of noninterference to be carried around with the
compiled program.  This would be interesting in distributed settings where we
would like to ship code around to others to run on their own machines.  There is
already a paper on the subject of mobile code for the Fabric
language~\cite{liu2009fabric}, a distributed computing variant of Jif,
discussing the problem of ``mobile code'', which operates by having the client
compile the code themselves~\cite{arden2012sharing}.  A proof-carrying code
system could possibly remove the need for the target machine to compile the code
themselves in order to ensure trust requirements are met.

Another use of a verified compiler would be the ability to verify extensions to
the language.  For example, the Jif and Fabric programming languages are
actively worked on and has seen multiple extensions over the years.  Although
it's pretty certain extensions to these languages that are published are
correct, requiring these extensions to be added to a verified compiler would
help ensure that the language updates will not invalidate pre-existing security
properties of the language, because adding the extension would require adding
code to cover the additional cases in the proofs.

\todo{more.}

\section{Conclusion}
\label{sec:conclusion}

In this paper, we present a simple information flow typed language \langName,
prove noninterference for the language, and discuss our experiences beginning to
mechanize this proof in Coq.  Although we did not complete our proof, we were
able to catch inaccuracies and subtleties that the proof we based our approach
on did not handle or explicitly cover.  This is the first step towards a
verified compiler for a language with information flow types such as Jif or
FlowCaml, which allows for a more trustworthy compiler and language definition,
by allowing users to verify the proofs in a proof assistant like Coq.  As far as
we know, a verified proof of noninterference for such a language has not been
implemented, let alone a verified compiler.  We are confident that, given more
time and a large amount of work, such a verified compiler could be realized for
a mature information flow language.

\section*{Acknowledgements}

We would like to thank Jon Sailor for chatting with us on the phone for hours to
help work through some of the more difficult problems we ran into using Coq.
Also, we would like to thank the authors of Software
Foundations~\cite{Pierce:sf}, which was the primary resource for learning Coq
for both authors.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
